{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.BaseInput = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar ReactDOM = _interopRequireWildcard(require(\"react-dom\"));\n\nvar _reactTippy = require(\"react-tippy\");\n\nvar Validators = _interopRequireWildcard(require(\"../../../validators\"));\n\nvar _Guid = _interopRequireDefault(require(\"../../utils/Guid\"));\n\nvar _ShallowEqual = require(\"../../utils/ShallowEqual\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar BaseInput =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(BaseInput, _React$Component);\n\n  function BaseInput(props) {\n    var _this;\n\n    var subscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    _classCallCheck(this, BaseInput);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseInput).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"componentId\", (0, _Guid.default)());\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"inputRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"containerRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"lastValidation\", void 0);\n\n    var res = _this.handleValueChange(_this.props.value, true, [], props, true);\n\n    _this.state = {\n      isValid: res.isValid,\n      errors: res.errors,\n      value: props.value ? props.value : '',\n      touched: false,\n      disabled: false,\n      focused: false,\n      handleValueChangeEnabled: true\n    };\n    _this.containerRef = React.createRef();\n    _this.inputRef = React.createRef();\n    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleBlur = _this.handleBlur.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.handleFocus = _this.handleFocus.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.setValid = _this.setValid.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.focus = _this.focus.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.scrollTo = _this.scrollTo.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.setInvalid = _this.setInvalid.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.disableComponent = _this.disableComponent.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.enableComponent = _this.enableComponent.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    if (subscribe) {\n      _this.subscribeSelf(props);\n    }\n\n    return _this;\n  }\n\n  _createClass(BaseInput, [{\n    key: \"getValidationClass\",\n    value: function getValidationClass(extraErrors) {\n      if (!this.props.showValidation || !this.state.touched) {\n        return 'validation__success';\n      }\n\n      return this.state.isValid && (!this.props.errors || this.props.errors.length === 0) && (!this.state.errors || this.state.errors.length === 0) && (!extraErrors || extraErrors.length === 0) ? 'validation__success' : 'validation__error';\n    }\n  }, {\n    key: \"renderDefaultValidation\",\n    value: function renderDefaultValidation(extraErrors) {\n      if (!this.props.showValidation) {\n        return null;\n      }\n\n      var finalErrors = this.state.errors;\n\n      if (!finalErrors) {\n        finalErrors = [];\n      }\n\n      if (extraErrors) {\n        finalErrors = finalErrors.concat(extraErrors);\n      }\n\n      if (this.props.errors) {\n        finalErrors = finalErrors.concat(this.props.errors);\n      }\n\n      finalErrors = finalErrors.filter(function (i) {\n        return i;\n      });\n\n      if (finalErrors.length > 0) {\n        this.lastValidation = finalErrors.map(function (item, index) {\n          return React.createElement(\"li\", {\n            key: index,\n            className: \"validation__item\"\n          }, item);\n        });\n      }\n\n      return React.createElement(\"div\", {\n        className: \"validation__container\"\n      }, React.createElement(\"ul\", {\n        className: \"validation__ul\"\n      }, this.lastValidation));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (!this.props.ignoreContext) {\n        this.props.formContext && this.props.formContext.unSubscribe(this.componentId);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.value !== this.props.value || nextProps.validators !== this.props.validators || nextProps.customValidators !== this.props.customValidators || nextProps.required !== this.props.required) {\n        this.handleValueChange(nextProps.value, true, [], nextProps);\n      }\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo() {\n      var domNode = ReactDOM.findDOMNode(this.containerRef.current);\n      domNode && domNode.scrollIntoView({\n        behavior: 'smooth'\n      });\n    }\n  }, {\n    key: \"touch\",\n    value: function touch() {\n      this.setState({\n        touched: true\n      });\n      this.handleValueChange(this.state.value || '');\n    }\n  }, {\n    key: \"unTouch\",\n    value: function unTouch() {\n      this.setState({\n        touched: false\n      });\n    }\n  }, {\n    key: \"disableComponent\",\n    value: function disableComponent() {\n      this.setState({\n        disabled: true\n      });\n    }\n  }, {\n    key: \"enableComponent\",\n    value: function enableComponent() {\n      this.setState({\n        disabled: false\n      });\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (this.inputRef) {\n        var domNode = ReactDOM.findDOMNode(this.inputRef.current);\n        domNode && domNode.focus();\n      }\n\n      this.touch();\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(event, isValid) {\n      var errors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var value = event.target.value;\n\n      if (!this.props.onTheFlightValidate || this.props.onTheFlightValidate && this.props.onTheFlightValidate(value)) {\n        var res = this.handleValueChange(value, isValid, errors);\n\n        if (this.props.onChange) {\n          this.props.onChange(event, res.isValid);\n        }\n      }\n    }\n  }, {\n    key: \"subscribeSelf\",\n    value: function subscribeSelf(props) {\n      if (!props.ignoreContext && props.formContext) {\n        props.formContext.subscribe(this.componentId, {\n          componentApi: {\n            disableComponent: this.disableComponent,\n            enableComponent: this.enableComponent,\n            touch: this.touch,\n            unTouch: this.unTouch,\n            scrollTo: this.scrollTo,\n            focus: this.focus\n          },\n          validation: {\n            isValid: this.state.isValid,\n            errors: this.state.errors,\n            name: this.props.validationName ? this.props.validationName : this.props.title ? this.props.title : this.props.label\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handleBlur\",\n    value: function handleBlur(e) {\n      this.props.onBlur && this.props.onBlur();\n      var state = {\n        focused: false\n      };\n\n      if (!this.state.touched && this.props.touchOn === 'blur') {\n        state = Object.assign(state, {\n          touched: true\n        });\n        this.handleValueChange(this.state.value);\n      }\n\n      this.setState(state);\n    }\n  }, {\n    key: \"handleFocus\",\n    value: function handleFocus(e) {\n      this.props.onFocus && this.props.onFocus(e);\n      var state = {\n        focused: true\n      };\n\n      if (!this.state.touched && this.props.touchOn === 'focus') {\n        state = Object.assign(state, {\n          touched: true\n        });\n        this.handleValueChange(this.state.value);\n      }\n\n      this.setState(state);\n    }\n  }, {\n    key: \"getDisabled\",\n    value: function getDisabled() {\n      return this.state.disabled ? this.state.disabled : this.props.disabled;\n    }\n  }, {\n    key: \"setValid\",\n    value: function setValid() {\n      var _this2 = this;\n\n      this.setState(function () {\n        return {\n          isValid: true,\n          errors: []\n        };\n      }, function () {\n        if (!_this2.props.ignoreContext) {\n          _this2.props.formContext && _this2.props.formContext.updateCallback(_this2.componentId, {\n            validation: {\n              isValid: true,\n              errors: []\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"setInvalid\",\n    value: function setInvalid() {\n      var _this3 = this;\n\n      var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.setState(function () {\n        return {\n          isValid: false,\n          errors: errors\n        };\n      }, function () {\n        if (!_this3.props.ignoreContext) {\n          _this3.props.formContext && _this3.props.formContext.updateCallback(_this3.componentId, {\n            validation: {\n              isValid: false,\n              errors: errors\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"renderLabel\",\n    value: function renderLabel() {\n      var touchable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this.props.tooltip || this.props.tooltip && this.props.title) {\n        return React.createElement(\"span\", {\n          className: touchable ? '' : 'label--no-touch'\n        }, this.props.label);\n      }\n\n      return React.createElement(React.Fragment, null, React.createElement(\"span\", {\n        className: touchable ? '' : 'label--no-touch'\n      }, this.props.label), this.renderTooltip());\n    }\n  }, {\n    key: \"renderTitle\",\n    value: function renderTitle() {\n      if (!this.props.tooltip) {\n        return this.props.title;\n      }\n\n      return React.createElement(React.Fragment, null, this.props.title, this.renderTooltip());\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var shouldUpdate = !(0, _ShallowEqual.shallowEqual)(this.props, nextProps, !this.props.reRendersWhenContextChanges ? 'formContext' : undefined) || !(0, _ShallowEqual.shallowEqual)(this.state, nextState);\n      return shouldUpdate;\n    }\n  }, {\n    key: \"handleValueChange\",\n    value: function handleValueChange(value) {\n      var isValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var errors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var props = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.props;\n      var initializing = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      if (!initializing && !this.state.handleValueChangeEnabled) {\n        return {\n          isValid: isValid,\n          errors: []\n        };\n      }\n\n      if (props.required && !value) {\n        errors.push('Required');\n        isValid = false;\n      } else {\n        if (!props.required && !value) {\n          isValid = true;\n        } else {\n          if (props.validators) {\n            isValid = true;\n            props.validators.forEach(function (validator) {\n              var validInner = false;\n\n              switch (validator) {\n                case 'email':\n                  validInner = new Validators.EmailValidator().Validate(value, props.required, function (error) {\n                    return errors.push(error);\n                  });\n                  break;\n\n                case 'number':\n                  validInner = new Validators.NumberValidator().Validate(value, props.required, function (error) {\n                    return errors.push(error);\n                  });\n                  break;\n\n                case 'latitude':\n                  validInner = new Validators.LatitudeValidator().Validate(value, props.required, function (error) {\n                    return errors.push(error);\n                  });\n                  break;\n\n                case 'longitude':\n                  validInner = new Validators.LongitudeValidator().Validate(value, props.required, function (error) {\n                    return errors.push(error);\n                  });\n                  break;\n\n                case 'url':\n                  validInner = new Validators.UrlValidator().Validate(value, props.required, function (error) {\n                    return errors.push(error);\n                  });\n                  break;\n\n                default:\n                  throw new Error(\"Validator \".concat(validator, \" not implemented\"));\n              }\n\n              if (isValid && !validInner) {\n                isValid = validInner;\n              }\n            });\n          }\n\n          if (props.customValidators) {\n            props.customValidators.forEach(function (customValidator) {\n              var validInner = false;\n              validInner = customValidator.Validate(value, props.required, function (error) {\n                return errors.push(error);\n              });\n\n              if (isValid && !validInner) {\n                isValid = validInner;\n              }\n            });\n          }\n        }\n      }\n\n      props.onErrorsChanged && props.onErrorsChanged(errors);\n\n      if (!initializing) {\n        this.setState({\n          value: value,\n          isValid: isValid,\n          errors: errors\n        });\n\n        if (!props.ignoreContext) {\n          props.formContext && props.formContext.updateCallback(this.componentId, {\n            validation: {\n              isValid: isValid,\n              errors: errors\n            }\n          });\n        }\n      }\n\n      return {\n        isValid: isValid,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"renderTooltip\",\n    value: function renderTooltip() {\n      return React.createElement(_reactTippy.Tooltip, _extends({\n        html: this.props.tooltip,\n        position: \"bottom\",\n        trigger: \"mouseenter\",\n        interactive: true,\n        className: \"label--help-icon__container\",\n        animateFill: false\n      }, this.props.tooltipProps), React.createElement(\"span\", {\n        className: \"label--help-icon\"\n      }, \"?\"));\n    }\n  }]);\n\n  return BaseInput;\n}(React.Component);\n\nexports.BaseInput = BaseInput;\n\n_defineProperty(BaseInput, \"defaultProps\", {\n  className: undefined,\n  required: false,\n  label: undefined,\n  disabled: false,\n  touchOn: 'focus',\n  ignoreContext: false,\n  showValidation: true,\n  formContext: undefined,\n  reRendersWhenContextChanges: false\n});\n\nvar _default = BaseInput;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}