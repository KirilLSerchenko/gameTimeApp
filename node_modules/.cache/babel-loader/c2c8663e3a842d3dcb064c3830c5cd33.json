{"ast":null,"code":"/*! Kefir.js v3.8.5\n *  https://github.com/kefirjs/kefir\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.Kefir = global.Kefir || {});\n})(this, function (exports) {\n  'use strict';\n\n  function createObj(proto) {\n    var F = function F() {};\n\n    F.prototype = proto;\n    return new F();\n  }\n\n  function extend(target\n  /*, mixin1, mixin2...*/\n  ) {\n    var length = arguments.length,\n        i = void 0,\n        prop = void 0;\n\n    for (i = 1; i < length; i++) {\n      for (prop in arguments[i]) {\n        target[prop] = arguments[i][prop];\n      }\n    }\n\n    return target;\n  }\n\n  function inherit(Child, Parent\n  /*, mixin1, mixin2...*/\n  ) {\n    var length = arguments.length,\n        i = void 0;\n    Child.prototype = createObj(Parent.prototype);\n    Child.prototype.constructor = Child;\n\n    for (i = 2; i < length; i++) {\n      extend(Child.prototype, arguments[i]);\n    }\n\n    return Child;\n  }\n\n  var NOTHING = ['<nothing>'];\n  var END = 'end';\n  var VALUE = 'value';\n  var ERROR = 'error';\n  var ANY = 'any';\n\n  function concat(a, b) {\n    var result = void 0,\n        length = void 0,\n        i = void 0,\n        j = void 0;\n\n    if (a.length === 0) {\n      return b;\n    }\n\n    if (b.length === 0) {\n      return a;\n    }\n\n    j = 0;\n    result = new Array(a.length + b.length);\n    length = a.length;\n\n    for (i = 0; i < length; i++, j++) {\n      result[j] = a[i];\n    }\n\n    length = b.length;\n\n    for (i = 0; i < length; i++, j++) {\n      result[j] = b[i];\n    }\n\n    return result;\n  }\n\n  function find(arr, value) {\n    var length = arr.length,\n        i = void 0;\n\n    for (i = 0; i < length; i++) {\n      if (arr[i] === value) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function findByPred(arr, pred) {\n    var length = arr.length,\n        i = void 0;\n\n    for (i = 0; i < length; i++) {\n      if (pred(arr[i])) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function cloneArray(input) {\n    var length = input.length,\n        result = new Array(length),\n        i = void 0;\n\n    for (i = 0; i < length; i++) {\n      result[i] = input[i];\n    }\n\n    return result;\n  }\n\n  function _remove(input, index) {\n    var length = input.length,\n        result = void 0,\n        i = void 0,\n        j = void 0;\n\n    if (index >= 0 && index < length) {\n      if (length === 1) {\n        return [];\n      } else {\n        result = new Array(length - 1);\n\n        for (i = 0, j = 0; i < length; i++) {\n          if (i !== index) {\n            result[j] = input[i];\n            j++;\n          }\n        }\n\n        return result;\n      }\n    } else {\n      return input;\n    }\n  }\n\n  function map(input, fn) {\n    var length = input.length,\n        result = new Array(length),\n        i = void 0;\n\n    for (i = 0; i < length; i++) {\n      result[i] = fn(input[i]);\n    }\n\n    return result;\n  }\n\n  function forEach(arr, fn) {\n    var length = arr.length,\n        i = void 0;\n\n    for (i = 0; i < length; i++) {\n      fn(arr[i]);\n    }\n  }\n\n  function fillArray(arr, value) {\n    var length = arr.length,\n        i = void 0;\n\n    for (i = 0; i < length; i++) {\n      arr[i] = value;\n    }\n  }\n\n  function contains(arr, value) {\n    return find(arr, value) !== -1;\n  }\n\n  function slide(cur, next, max) {\n    var length = Math.min(max, cur.length + 1),\n        offset = cur.length - length + 1,\n        result = new Array(length),\n        i = void 0;\n\n    for (i = offset; i < length; i++) {\n      result[i - offset] = cur[i];\n    }\n\n    result[length - 1] = next;\n    return result;\n  }\n\n  function callSubscriber(type, fn, event) {\n    if (type === ANY) {\n      fn(event);\n    } else if (type === event.type) {\n      if (type === VALUE || type === ERROR) {\n        fn(event.value);\n      } else {\n        fn();\n      }\n    }\n  }\n\n  function Dispatcher() {\n    this._items = [];\n    this._spies = [];\n    this._inLoop = 0;\n    this._removedItems = null;\n  }\n\n  extend(Dispatcher.prototype, {\n    add: function add(type, fn) {\n      this._items = concat(this._items, [{\n        type: type,\n        fn: fn\n      }]);\n      return this._items.length;\n    },\n    remove: function remove(type, fn) {\n      var index = findByPred(this._items, function (x) {\n        return x.type === type && x.fn === fn;\n      }); // if we're currently in a notification loop,\n      // remember this subscriber was removed\n\n      if (this._inLoop !== 0 && index !== -1) {\n        if (this._removedItems === null) {\n          this._removedItems = [];\n        }\n\n        this._removedItems.push(this._items[index]);\n      }\n\n      this._items = _remove(this._items, index);\n      return this._items.length;\n    },\n    addSpy: function addSpy(fn) {\n      this._spies = concat(this._spies, [fn]);\n      return this._spies.length;\n    },\n    // Because spies are only ever a function that perform logging as\n    // their only side effect, we don't need the same complicated\n    // removal logic like in remove()\n    removeSpy: function removeSpy(fn) {\n      this._spies = _remove(this._spies, this._spies.indexOf(fn));\n      return this._spies.length;\n    },\n    dispatch: function dispatch(event) {\n      this._inLoop++;\n\n      for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n        spies[i](event);\n      }\n\n      for (var _i = 0, items = this._items; _i < items.length; _i++) {\n        // cleanup was called\n        if (this._items === null) {\n          break;\n        } // this subscriber was removed\n\n\n        if (this._removedItems !== null && contains(this._removedItems, items[_i])) {\n          continue;\n        }\n\n        callSubscriber(items[_i].type, items[_i].fn, event);\n      }\n\n      this._inLoop--;\n\n      if (this._inLoop === 0) {\n        this._removedItems = null;\n      }\n    },\n    cleanup: function cleanup() {\n      this._items = null;\n      this._spies = null;\n    }\n  });\n\n  function Observable() {\n    this._dispatcher = new Dispatcher();\n    this._active = false;\n    this._alive = true;\n    this._activating = false;\n    this._logHandlers = null;\n    this._spyHandlers = null;\n  }\n\n  extend(Observable.prototype, {\n    _name: 'observable',\n    _onActivation: function _onActivation() {},\n    _onDeactivation: function _onDeactivation() {},\n    _setActive: function _setActive(active) {\n      if (this._active !== active) {\n        this._active = active;\n\n        if (active) {\n          this._activating = true;\n\n          this._onActivation();\n\n          this._activating = false;\n        } else {\n          this._onDeactivation();\n        }\n      }\n    },\n    _clear: function _clear() {\n      this._setActive(false);\n\n      this._dispatcher.cleanup();\n\n      this._dispatcher = null;\n      this._logHandlers = null;\n    },\n    _emit: function _emit(type, x) {\n      switch (type) {\n        case VALUE:\n          return this._emitValue(x);\n\n        case ERROR:\n          return this._emitError(x);\n\n        case END:\n          return this._emitEnd();\n      }\n    },\n    _emitValue: function _emitValue(value) {\n      if (this._alive) {\n        this._dispatcher.dispatch({\n          type: VALUE,\n          value: value\n        });\n      }\n    },\n    _emitError: function _emitError(value) {\n      if (this._alive) {\n        this._dispatcher.dispatch({\n          type: ERROR,\n          value: value\n        });\n      }\n    },\n    _emitEnd: function _emitEnd() {\n      if (this._alive) {\n        this._alive = false;\n\n        this._dispatcher.dispatch({\n          type: END\n        });\n\n        this._clear();\n      }\n    },\n    _on: function _on(type, fn) {\n      if (this._alive) {\n        this._dispatcher.add(type, fn);\n\n        this._setActive(true);\n      } else {\n        callSubscriber(type, fn, {\n          type: END\n        });\n      }\n\n      return this;\n    },\n    _off: function _off(type, fn) {\n      if (this._alive) {\n        var count = this._dispatcher.remove(type, fn);\n\n        if (count === 0) {\n          this._setActive(false);\n        }\n      }\n\n      return this;\n    },\n    onValue: function onValue(fn) {\n      return this._on(VALUE, fn);\n    },\n    onError: function onError(fn) {\n      return this._on(ERROR, fn);\n    },\n    onEnd: function onEnd(fn) {\n      return this._on(END, fn);\n    },\n    onAny: function onAny(fn) {\n      return this._on(ANY, fn);\n    },\n    offValue: function offValue(fn) {\n      return this._off(VALUE, fn);\n    },\n    offError: function offError(fn) {\n      return this._off(ERROR, fn);\n    },\n    offEnd: function offEnd(fn) {\n      return this._off(END, fn);\n    },\n    offAny: function offAny(fn) {\n      return this._off(ANY, fn);\n    },\n    observe: function observe(observerOrOnValue, onError, onEnd) {\n      var _this = this;\n\n      var closed = false;\n      var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? {\n        value: observerOrOnValue,\n        error: onError,\n        end: onEnd\n      } : observerOrOnValue;\n\n      var handler = function handler(event) {\n        if (event.type === END) {\n          closed = true;\n        }\n\n        if (event.type === VALUE && observer.value) {\n          observer.value(event.value);\n        } else if (event.type === ERROR && observer.error) {\n          observer.error(event.value);\n        } else if (event.type === END && observer.end) {\n          observer.end(event.value);\n        }\n      };\n\n      this.onAny(handler);\n      return {\n        unsubscribe: function unsubscribe() {\n          if (!closed) {\n            _this.offAny(handler);\n\n            closed = true;\n          }\n        },\n\n        get closed() {\n          return closed;\n        }\n\n      };\n    },\n    // A and B must be subclasses of Stream and Property (order doesn't matter)\n    _ofSameType: function _ofSameType(A, B) {\n      return A.prototype.getType() === this.getType() ? A : B;\n    },\n    setName: function setName(sourceObs\n    /* optional */\n    , selfName) {\n      this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n      return this;\n    },\n    log: function log() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n      var isCurrent = void 0;\n\n      var handler = function handler(event) {\n        var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n\n        if (event.type === END) {\n          console.log(name, type);\n        } else {\n          console.log(name, type, event.value);\n        }\n      };\n\n      if (this._alive) {\n        if (!this._logHandlers) {\n          this._logHandlers = [];\n        }\n\n        this._logHandlers.push({\n          name: name,\n          handler: handler\n        });\n      }\n\n      isCurrent = true;\n      this.onAny(handler);\n      isCurrent = false;\n      return this;\n    },\n    offLog: function offLog() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n      if (this._logHandlers) {\n        var handlerIndex = findByPred(this._logHandlers, function (obj) {\n          return obj.name === name;\n        });\n\n        if (handlerIndex !== -1) {\n          this.offAny(this._logHandlers[handlerIndex].handler);\n\n          this._logHandlers.splice(handlerIndex, 1);\n        }\n      }\n\n      return this;\n    },\n    spy: function spy() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n      var handler = function handler(event) {\n        var type = '<' + event.type + '>';\n\n        if (event.type === END) {\n          console.log(name, type);\n        } else {\n          console.log(name, type, event.value);\n        }\n      };\n\n      if (this._alive) {\n        if (!this._spyHandlers) {\n          this._spyHandlers = [];\n        }\n\n        this._spyHandlers.push({\n          name: name,\n          handler: handler\n        });\n\n        this._dispatcher.addSpy(handler);\n      }\n\n      return this;\n    },\n    offSpy: function offSpy() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n      if (this._spyHandlers) {\n        var handlerIndex = findByPred(this._spyHandlers, function (obj) {\n          return obj.name === name;\n        });\n\n        if (handlerIndex !== -1) {\n          this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n\n          this._spyHandlers.splice(handlerIndex, 1);\n        }\n      }\n\n      return this;\n    }\n  }); // extend() can't handle `toString` in IE8\n\n  Observable.prototype.toString = function () {\n    return '[' + this._name + ']';\n  };\n\n  function Stream() {\n    Observable.call(this);\n  }\n\n  inherit(Stream, Observable, {\n    _name: 'stream',\n    getType: function getType() {\n      return 'stream';\n    }\n  });\n\n  function Property() {\n    Observable.call(this);\n    this._currentEvent = null;\n  }\n\n  inherit(Property, Observable, {\n    _name: 'property',\n    _emitValue: function _emitValue(value) {\n      if (this._alive) {\n        this._currentEvent = {\n          type: VALUE,\n          value: value\n        };\n\n        if (!this._activating) {\n          this._dispatcher.dispatch({\n            type: VALUE,\n            value: value\n          });\n        }\n      }\n    },\n    _emitError: function _emitError(value) {\n      if (this._alive) {\n        this._currentEvent = {\n          type: ERROR,\n          value: value\n        };\n\n        if (!this._activating) {\n          this._dispatcher.dispatch({\n            type: ERROR,\n            value: value\n          });\n        }\n      }\n    },\n    _emitEnd: function _emitEnd() {\n      if (this._alive) {\n        this._alive = false;\n\n        if (!this._activating) {\n          this._dispatcher.dispatch({\n            type: END\n          });\n        }\n\n        this._clear();\n      }\n    },\n    _on: function _on(type, fn) {\n      if (this._alive) {\n        this._dispatcher.add(type, fn);\n\n        this._setActive(true);\n      }\n\n      if (this._currentEvent !== null) {\n        callSubscriber(type, fn, this._currentEvent);\n      }\n\n      if (!this._alive) {\n        callSubscriber(type, fn, {\n          type: END\n        });\n      }\n\n      return this;\n    },\n    getType: function getType() {\n      return 'property';\n    }\n  });\n  var neverS = new Stream();\n\n  neverS._emitEnd();\n\n  neverS._name = 'never';\n\n  function never() {\n    return neverS;\n  }\n\n  function timeBased(mixin) {\n    function AnonymousStream(wait, options) {\n      var _this = this;\n\n      Stream.call(this);\n      this._wait = wait;\n      this._intervalId = null;\n\n      this._$onTick = function () {\n        return _this._onTick();\n      };\n\n      this._init(options);\n    }\n\n    inherit(AnonymousStream, Stream, {\n      _init: function _init() {},\n      _free: function _free() {},\n      _onTick: function _onTick() {},\n      _onActivation: function _onActivation() {\n        this._intervalId = setInterval(this._$onTick, this._wait);\n      },\n      _onDeactivation: function _onDeactivation() {\n        if (this._intervalId !== null) {\n          clearInterval(this._intervalId);\n          this._intervalId = null;\n        }\n      },\n      _clear: function _clear() {\n        Stream.prototype._clear.call(this);\n\n        this._$onTick = null;\n\n        this._free();\n      }\n    }, mixin);\n    return AnonymousStream;\n  }\n\n  var S = timeBased({\n    _name: 'later',\n    _init: function _init(_ref) {\n      var x = _ref.x;\n      this._x = x;\n    },\n    _free: function _free() {\n      this._x = null;\n    },\n    _onTick: function _onTick() {\n      this._emitValue(this._x);\n\n      this._emitEnd();\n    }\n  });\n\n  function later(wait, x) {\n    return new S(wait, {\n      x: x\n    });\n  }\n\n  var S$1 = timeBased({\n    _name: 'interval',\n    _init: function _init(_ref) {\n      var x = _ref.x;\n      this._x = x;\n    },\n    _free: function _free() {\n      this._x = null;\n    },\n    _onTick: function _onTick() {\n      this._emitValue(this._x);\n    }\n  });\n\n  function interval(wait, x) {\n    return new S$1(wait, {\n      x: x\n    });\n  }\n\n  var S$2 = timeBased({\n    _name: 'sequentially',\n    _init: function _init(_ref) {\n      var xs = _ref.xs;\n      this._xs = cloneArray(xs);\n    },\n    _free: function _free() {\n      this._xs = null;\n    },\n    _onTick: function _onTick() {\n      if (this._xs.length === 1) {\n        this._emitValue(this._xs[0]);\n\n        this._emitEnd();\n      } else {\n        this._emitValue(this._xs.shift());\n      }\n    }\n  });\n\n  function sequentially(wait, xs) {\n    return xs.length === 0 ? never() : new S$2(wait, {\n      xs: xs\n    });\n  }\n\n  var S$3 = timeBased({\n    _name: 'fromPoll',\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _onTick: function _onTick() {\n      var fn = this._fn;\n\n      this._emitValue(fn());\n    }\n  });\n\n  function fromPoll(wait, fn) {\n    return new S$3(wait, {\n      fn: fn\n    });\n  }\n\n  function emitter(obs) {\n    function value(x) {\n      obs._emitValue(x);\n\n      return obs._active;\n    }\n\n    function error(x) {\n      obs._emitError(x);\n\n      return obs._active;\n    }\n\n    function end() {\n      obs._emitEnd();\n\n      return obs._active;\n    }\n\n    function event(e) {\n      obs._emit(e.type, e.value);\n\n      return obs._active;\n    }\n\n    return {\n      value: value,\n      error: error,\n      end: end,\n      event: event,\n      // legacy\n      emit: value,\n      emitEvent: event\n    };\n  }\n\n  var S$4 = timeBased({\n    _name: 'withInterval',\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n      this._emitter = emitter(this);\n    },\n    _free: function _free() {\n      this._fn = null;\n      this._emitter = null;\n    },\n    _onTick: function _onTick() {\n      var fn = this._fn;\n      fn(this._emitter);\n    }\n  });\n\n  function withInterval(wait, fn) {\n    return new S$4(wait, {\n      fn: fn\n    });\n  }\n\n  function S$5(fn) {\n    Stream.call(this);\n    this._fn = fn;\n    this._unsubscribe = null;\n  }\n\n  inherit(S$5, Stream, {\n    _name: 'stream',\n    _onActivation: function _onActivation() {\n      var fn = this._fn;\n      var unsubscribe = fn(emitter(this));\n      this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null; // fix https://github.com/kefirjs/kefir/issues/35\n\n      if (!this._active) {\n        this._callUnsubscribe();\n      }\n    },\n    _callUnsubscribe: function _callUnsubscribe() {\n      if (this._unsubscribe !== null) {\n        this._unsubscribe();\n\n        this._unsubscribe = null;\n      }\n    },\n    _onDeactivation: function _onDeactivation() {\n      this._callUnsubscribe();\n    },\n    _clear: function _clear() {\n      Stream.prototype._clear.call(this);\n\n      this._fn = null;\n    }\n  });\n\n  function stream(fn) {\n    return new S$5(fn);\n  }\n\n  function fromCallback(callbackConsumer) {\n    var called = false;\n    return stream(function (emitter) {\n      if (!called) {\n        callbackConsumer(function (x) {\n          emitter.emit(x);\n          emitter.end();\n        });\n        called = true;\n      }\n    }).setName('fromCallback');\n  }\n\n  function fromNodeCallback(callbackConsumer) {\n    var called = false;\n    return stream(function (emitter) {\n      if (!called) {\n        callbackConsumer(function (error, x) {\n          if (error) {\n            emitter.error(error);\n          } else {\n            emitter.emit(x);\n          }\n\n          emitter.end();\n        });\n        called = true;\n      }\n    }).setName('fromNodeCallback');\n  }\n\n  function spread(fn, length) {\n    switch (length) {\n      case 0:\n        return function () {\n          return fn();\n        };\n\n      case 1:\n        return function (a) {\n          return fn(a[0]);\n        };\n\n      case 2:\n        return function (a) {\n          return fn(a[0], a[1]);\n        };\n\n      case 3:\n        return function (a) {\n          return fn(a[0], a[1], a[2]);\n        };\n\n      case 4:\n        return function (a) {\n          return fn(a[0], a[1], a[2], a[3]);\n        };\n\n      default:\n        return function (a) {\n          return fn.apply(null, a);\n        };\n    }\n  }\n\n  function apply(fn, c, a) {\n    var aLength = a ? a.length : 0;\n\n    if (c == null) {\n      switch (aLength) {\n        case 0:\n          return fn();\n\n        case 1:\n          return fn(a[0]);\n\n        case 2:\n          return fn(a[0], a[1]);\n\n        case 3:\n          return fn(a[0], a[1], a[2]);\n\n        case 4:\n          return fn(a[0], a[1], a[2], a[3]);\n\n        default:\n          return fn.apply(null, a);\n      }\n    } else {\n      switch (aLength) {\n        case 0:\n          return fn.call(c);\n\n        default:\n          return fn.apply(c, a);\n      }\n    }\n  }\n\n  function fromSubUnsub(sub, unsub, transformer\n  /* Function | falsey */\n  ) {\n    return stream(function (emitter) {\n      var handler = transformer ? function () {\n        emitter.emit(apply(transformer, this, arguments));\n      } : function (x) {\n        emitter.emit(x);\n      };\n      sub(handler);\n      return function () {\n        return unsub(handler);\n      };\n    }).setName('fromSubUnsub');\n  }\n\n  var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\n  function fromEvents(target, eventName, transformer) {\n    var sub = void 0,\n        unsub = void 0;\n\n    for (var i = 0; i < pairs.length; i++) {\n      if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n        sub = pairs[i][0];\n        unsub = pairs[i][1];\n        break;\n      }\n    }\n\n    if (sub === undefined) {\n      throw new Error(\"target don't support any of \" + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n    }\n\n    return fromSubUnsub(function (handler) {\n      return target[sub](eventName, handler);\n    }, function (handler) {\n      return target[unsub](eventName, handler);\n    }, transformer).setName('fromEvents');\n  } // HACK:\n  //   We don't call parent Class constructor, but instead putting all necessary\n  //   properties into prototype to simulate ended Property\n  //   (see Propperty and Observable classes).\n\n\n  function P(value) {\n    this._currentEvent = {\n      type: 'value',\n      value: value,\n      current: true\n    };\n  }\n\n  inherit(P, Property, {\n    _name: 'constant',\n    _active: false,\n    _activating: false,\n    _alive: false,\n    _dispatcher: null,\n    _logHandlers: null\n  });\n\n  function constant(x) {\n    return new P(x);\n  } // HACK:\n  //   We don't call parent Class constructor, but instead putting all necessary\n  //   properties into prototype to simulate ended Property\n  //   (see Propperty and Observable classes).\n\n\n  function P$1(value) {\n    this._currentEvent = {\n      type: 'error',\n      value: value,\n      current: true\n    };\n  }\n\n  inherit(P$1, Property, {\n    _name: 'constantError',\n    _active: false,\n    _activating: false,\n    _alive: false,\n    _dispatcher: null,\n    _logHandlers: null\n  });\n\n  function constantError(x) {\n    return new P$1(x);\n  }\n\n  function createConstructor(BaseClass, name) {\n    return function AnonymousObservable(source, options) {\n      var _this = this;\n\n      BaseClass.call(this);\n      this._source = source;\n      this._name = source._name + '.' + name;\n\n      this._init(options);\n\n      this._$handleAny = function (event) {\n        return _this._handleAny(event);\n      };\n    };\n  }\n\n  function createClassMethods(BaseClass) {\n    return {\n      _init: function _init() {},\n      _free: function _free() {},\n      _handleValue: function _handleValue(x) {\n        this._emitValue(x);\n      },\n      _handleError: function _handleError(x) {\n        this._emitError(x);\n      },\n      _handleEnd: function _handleEnd() {\n        this._emitEnd();\n      },\n      _handleAny: function _handleAny(event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handleValue(event.value);\n\n          case ERROR:\n            return this._handleError(event.value);\n\n          case END:\n            return this._handleEnd();\n        }\n      },\n      _onActivation: function _onActivation() {\n        this._source.onAny(this._$handleAny);\n      },\n      _onDeactivation: function _onDeactivation() {\n        this._source.offAny(this._$handleAny);\n      },\n      _clear: function _clear() {\n        BaseClass.prototype._clear.call(this);\n\n        this._source = null;\n        this._$handleAny = null;\n\n        this._free();\n      }\n    };\n  }\n\n  function createStream(name, mixin) {\n    var S = createConstructor(Stream, name);\n    inherit(S, Stream, createClassMethods(Stream), mixin);\n    return S;\n  }\n\n  function createProperty(name, mixin) {\n    var P = createConstructor(Property, name);\n    inherit(P, Property, createClassMethods(Property), mixin);\n    return P;\n  }\n\n  var P$2 = createProperty('toProperty', {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._getInitialCurrent = fn;\n    },\n    _onActivation: function _onActivation() {\n      if (this._getInitialCurrent !== null) {\n        var getInitial = this._getInitialCurrent;\n\n        this._emitValue(getInitial());\n      }\n\n      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\n    }\n  });\n\n  function toProperty(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (fn !== null && typeof fn !== 'function') {\n      throw new Error('You should call toProperty() with a function or no arguments.');\n    }\n\n    return new P$2(obs, {\n      fn: fn\n    });\n  }\n\n  var S$6 = createStream('changes', {\n    _handleValue: function _handleValue(x) {\n      if (!this._activating) {\n        this._emitValue(x);\n      }\n    },\n    _handleError: function _handleError(x) {\n      if (!this._activating) {\n        this._emitError(x);\n      }\n    }\n  });\n\n  function changes(obs) {\n    return new S$6(obs);\n  }\n\n  function fromPromise(promise) {\n    var called = false;\n    var result = stream(function (emitter) {\n      if (!called) {\n        var onValue = function onValue(x) {\n          emitter.emit(x);\n          emitter.end();\n        };\n\n        var onError = function onError(x) {\n          emitter.error(x);\n          emitter.end();\n        };\n\n        var _promise = promise.then(onValue, onError); // prevent libraries like 'Q' or 'when' from swallowing exceptions\n\n\n        if (_promise && typeof _promise.done === 'function') {\n          _promise.done();\n        }\n\n        called = true;\n      }\n    });\n    return toProperty(result, null).setName('fromPromise');\n  }\n\n  function getGlodalPromise() {\n    if (typeof Promise === 'function') {\n      return Promise;\n    } else {\n      throw new Error(\"There isn't default Promise, use shim or parameter\");\n    }\n  }\n\n  var toPromise = function toPromise(obs) {\n    var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();\n    var last = null;\n    return new Promise(function (resolve, reject) {\n      obs.onAny(function (event) {\n        if (event.type === END && last !== null) {\n          (last.type === VALUE ? resolve : reject)(last.value);\n          last = null;\n        } else {\n          last = event;\n        }\n      });\n    });\n  };\n\n  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var ponyfill = createCommonjsModule(function (module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports['default'] = symbolObservablePonyfill;\n\n    function symbolObservablePonyfill(root) {\n      var result;\n      var _Symbol = root.Symbol;\n\n      if (typeof _Symbol === 'function') {\n        if (_Symbol.observable) {\n          result = _Symbol.observable;\n        } else {\n          result = _Symbol('observable');\n          _Symbol.observable = result;\n        }\n      } else {\n        result = '@@observable';\n      }\n\n      return result;\n    }\n  });\n  var index$1 = createCommonjsModule(function (module, exports) {\n    'use strict';\n\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n\n    var _ponyfill2 = _interopRequireDefault(ponyfill);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        'default': obj\n      };\n    }\n\n    var root;\n    /* global window */\n\n    if (typeof self !== 'undefined') {\n      root = self;\n    } else if (typeof window !== 'undefined') {\n      root = window;\n    } else if (typeof commonjsGlobal !== 'undefined') {\n      root = commonjsGlobal;\n    } else {\n      root = module;\n    }\n\n    var result = (0, _ponyfill2['default'])(root);\n    exports['default'] = result;\n  });\n  var index = index$1; // this file contains some hot JS modules systems stuff\n\n  var $$observable = index.default ? index.default : index;\n\n  function fromESObservable(_observable) {\n    var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n    return stream(function (emitter) {\n      var unsub = observable.subscribe({\n        error: function error(_error) {\n          emitter.error(_error);\n          emitter.end();\n        },\n        next: function next(value) {\n          emitter.emit(value);\n        },\n        complete: function complete() {\n          emitter.end();\n        }\n      });\n\n      if (unsub.unsubscribe) {\n        return function () {\n          unsub.unsubscribe();\n        };\n      } else {\n        return unsub;\n      }\n    }).setName('fromESObservable');\n  }\n\n  function ESObservable(observable) {\n    this._observable = observable.takeErrors(1);\n  }\n\n  extend(ESObservable.prototype, {\n    subscribe: function subscribe(observerOrOnNext, onError, onComplete) {\n      var _this = this;\n\n      var observer = typeof observerOrOnNext === 'function' ? {\n        next: observerOrOnNext,\n        error: onError,\n        complete: onComplete\n      } : observerOrOnNext;\n\n      var fn = function fn(event) {\n        if (event.type === END) {\n          closed = true;\n        }\n\n        if (event.type === VALUE && observer.next) {\n          observer.next(event.value);\n        } else if (event.type === ERROR && observer.error) {\n          observer.error(event.value);\n        } else if (event.type === END && observer.complete) {\n          observer.complete(event.value);\n        }\n      };\n\n      this._observable.onAny(fn);\n\n      var closed = false;\n      var subscription = {\n        unsubscribe: function unsubscribe() {\n          closed = true;\n\n          _this._observable.offAny(fn);\n        },\n\n        get closed() {\n          return closed;\n        }\n\n      };\n      return subscription;\n    }\n  }); // Need to assign directly b/c Symbols aren't enumerable.\n\n  ESObservable.prototype[$$observable] = function () {\n    return this;\n  };\n\n  function toESObservable() {\n    return new ESObservable(this);\n  }\n\n  function collect(source, keys, values) {\n    for (var prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        keys.push(prop);\n        values.push(source[prop]);\n      }\n    }\n  }\n\n  function defaultErrorsCombinator(errors) {\n    var latestError = void 0;\n\n    for (var i = 0; i < errors.length; i++) {\n      if (errors[i] !== undefined) {\n        if (latestError === undefined || latestError.index < errors[i].index) {\n          latestError = errors[i];\n        }\n      }\n    }\n\n    return latestError.error;\n  }\n\n  function Combine(active, passive, combinator) {\n    var _this = this;\n\n    Stream.call(this);\n    this._activeCount = active.length;\n    this._sources = concat(active, passive);\n    this._combinator = combinator;\n    this._aliveCount = 0;\n    this._latestValues = new Array(this._sources.length);\n    this._latestErrors = new Array(this._sources.length);\n    fillArray(this._latestValues, NOTHING);\n    this._emitAfterActivation = false;\n    this._endAfterActivation = false;\n    this._latestErrorIndex = 0;\n    this._$handlers = [];\n\n    var _loop = function _loop(i) {\n      _this._$handlers.push(function (event) {\n        return _this._handleAny(i, event);\n      });\n    };\n\n    for (var i = 0; i < this._sources.length; i++) {\n      _loop(i);\n    }\n  }\n\n  inherit(Combine, Stream, {\n    _name: 'combine',\n    _onActivation: function _onActivation() {\n      this._aliveCount = this._activeCount; // we need to suscribe to _passive_ sources before _active_\n      // (see https://github.com/kefirjs/kefir/issues/98)\n\n      for (var i = this._activeCount; i < this._sources.length; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n\n      for (var _i = 0; _i < this._activeCount; _i++) {\n        this._sources[_i].onAny(this._$handlers[_i]);\n      }\n\n      if (this._emitAfterActivation) {\n        this._emitAfterActivation = false;\n\n        this._emitIfFull();\n      }\n\n      if (this._endAfterActivation) {\n        this._emitEnd();\n      }\n    },\n    _onDeactivation: function _onDeactivation() {\n      var length = this._sources.length,\n          i = void 0;\n\n      for (i = 0; i < length; i++) {\n        this._sources[i].offAny(this._$handlers[i]);\n      }\n    },\n    _emitIfFull: function _emitIfFull() {\n      var hasAllValues = true;\n      var hasErrors = false;\n      var length = this._latestValues.length;\n      var valuesCopy = new Array(length);\n      var errorsCopy = new Array(length);\n\n      for (var i = 0; i < length; i++) {\n        valuesCopy[i] = this._latestValues[i];\n        errorsCopy[i] = this._latestErrors[i];\n\n        if (valuesCopy[i] === NOTHING) {\n          hasAllValues = false;\n        }\n\n        if (errorsCopy[i] !== undefined) {\n          hasErrors = true;\n        }\n      }\n\n      if (hasAllValues) {\n        var combinator = this._combinator;\n\n        this._emitValue(combinator(valuesCopy));\n      }\n\n      if (hasErrors) {\n        this._emitError(defaultErrorsCombinator(errorsCopy));\n      }\n    },\n    _handleAny: function _handleAny(i, event) {\n      if (event.type === VALUE || event.type === ERROR) {\n        if (event.type === VALUE) {\n          this._latestValues[i] = event.value;\n          this._latestErrors[i] = undefined;\n        }\n\n        if (event.type === ERROR) {\n          this._latestValues[i] = NOTHING;\n          this._latestErrors[i] = {\n            index: this._latestErrorIndex++,\n            error: event.value\n          };\n        }\n\n        if (i < this._activeCount) {\n          if (this._activating) {\n            this._emitAfterActivation = true;\n          } else {\n            this._emitIfFull();\n          }\n        }\n      } else {\n        // END\n        if (i < this._activeCount) {\n          this._aliveCount--;\n\n          if (this._aliveCount === 0) {\n            if (this._activating) {\n              this._endAfterActivation = true;\n            } else {\n              this._emitEnd();\n            }\n          }\n        }\n      }\n    },\n    _clear: function _clear() {\n      Stream.prototype._clear.call(this);\n\n      this._sources = null;\n      this._latestValues = null;\n      this._latestErrors = null;\n      this._combinator = null;\n      this._$handlers = null;\n    }\n  });\n\n  function combineAsArray(active) {\n    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var combinator = arguments[2];\n\n    if (!Array.isArray(passive)) {\n      throw new Error('Combine can only combine active and passive collections of the same type.');\n    }\n\n    combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {\n      return x;\n    };\n    return active.length === 0 ? never() : new Combine(active, passive, combinator);\n  }\n\n  function combineAsObject(active) {\n    var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var combinator = arguments[2];\n\n    if (typeof passive !== 'object' || Array.isArray(passive)) {\n      throw new Error('Combine can only combine active and passive collections of the same type.');\n    }\n\n    var keys = [],\n        activeObservables = [],\n        passiveObservables = [];\n    collect(active, keys, activeObservables);\n    collect(passive, keys, passiveObservables);\n\n    var objectify = function objectify(values) {\n      var event = {};\n\n      for (var i = values.length - 1; 0 <= i; i--) {\n        event[keys[i]] = values[i];\n      }\n\n      return combinator ? combinator(event) : event;\n    };\n\n    return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n  }\n\n  function combine(active, passive, combinator) {\n    if (typeof passive === 'function') {\n      combinator = passive;\n      passive = undefined;\n    }\n\n    return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n  }\n\n  var Observable$2 = {\n    empty: function empty() {\n      return never();\n    },\n    // Monoid based on merge() seems more useful than one based on concat().\n    concat: function concat(a, b) {\n      return a.merge(b);\n    },\n    of: function of(x) {\n      return constant(x);\n    },\n    map: function map(fn, obs) {\n      return obs.map(fn);\n    },\n    bimap: function bimap(fnErr, fnVal, obs) {\n      return obs.mapErrors(fnErr).map(fnVal);\n    },\n    // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n    // different (not very useful) behavior. But spec requires that if method can be derived\n    // it must have the same behavior as hand-written method. We intentionally violate the spec\n    // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n    ap: function ap(obsFn, obsVal) {\n      return combine([obsFn, obsVal], function (fn, val) {\n        return fn(val);\n      });\n    },\n    chain: function chain(fn, obs) {\n      return obs.flatMap(fn);\n    }\n  };\n  var staticLand = Object.freeze({\n    Observable: Observable$2\n  });\n  var mixin = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n\n      this._emitValue(fn(x));\n    }\n  };\n  var S$7 = createStream('map', mixin);\n  var P$3 = createProperty('map', mixin);\n\n  var id = function id(x) {\n    return x;\n  };\n\n  function map$1(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;\n    return new (obs._ofSameType(S$7, P$3))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$1 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n\n      if (fn(x)) {\n        this._emitValue(x);\n      }\n    }\n  };\n  var S$8 = createStream('filter', mixin$1);\n  var P$4 = createProperty('filter', mixin$1);\n\n  var id$1 = function id$1(x) {\n    return x;\n  };\n\n  function filter(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;\n    return new (obs._ofSameType(S$8, P$4))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$2 = {\n    _init: function _init(_ref) {\n      var n = _ref.n;\n      this._n = n;\n\n      if (n <= 0) {\n        this._emitEnd();\n      }\n    },\n    _handleValue: function _handleValue(x) {\n      if (this._n === 0) {\n        return;\n      }\n\n      this._n--;\n\n      this._emitValue(x);\n\n      if (this._n === 0) {\n        this._emitEnd();\n      }\n    }\n  };\n  var S$9 = createStream('take', mixin$2);\n  var P$5 = createProperty('take', mixin$2);\n\n  function take(obs, n) {\n    return new (obs._ofSameType(S$9, P$5))(obs, {\n      n: n\n    });\n  }\n\n  var mixin$3 = {\n    _init: function _init(_ref) {\n      var n = _ref.n;\n      this._n = n;\n\n      if (n <= 0) {\n        this._emitEnd();\n      }\n    },\n    _handleError: function _handleError(x) {\n      if (this._n === 0) {\n        return;\n      }\n\n      this._n--;\n\n      this._emitError(x);\n\n      if (this._n === 0) {\n        this._emitEnd();\n      }\n    }\n  };\n  var S$10 = createStream('takeErrors', mixin$3);\n  var P$6 = createProperty('takeErrors', mixin$3);\n\n  function takeErrors(obs, n) {\n    return new (obs._ofSameType(S$10, P$6))(obs, {\n      n: n\n    });\n  }\n\n  var mixin$4 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n\n      if (fn(x)) {\n        this._emitValue(x);\n      } else {\n        this._emitEnd();\n      }\n    }\n  };\n  var S$11 = createStream('takeWhile', mixin$4);\n  var P$7 = createProperty('takeWhile', mixin$4);\n\n  var id$2 = function id$2(x) {\n    return x;\n  };\n\n  function takeWhile(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;\n    return new (obs._ofSameType(S$11, P$7))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$5 = {\n    _init: function _init() {\n      this._lastValue = NOTHING;\n    },\n    _free: function _free() {\n      this._lastValue = null;\n    },\n    _handleValue: function _handleValue(x) {\n      this._lastValue = x;\n    },\n    _handleEnd: function _handleEnd() {\n      if (this._lastValue !== NOTHING) {\n        this._emitValue(this._lastValue);\n      }\n\n      this._emitEnd();\n    }\n  };\n  var S$12 = createStream('last', mixin$5);\n  var P$8 = createProperty('last', mixin$5);\n\n  function last(obs) {\n    return new (obs._ofSameType(S$12, P$8))(obs);\n  }\n\n  var mixin$6 = {\n    _init: function _init(_ref) {\n      var n = _ref.n;\n      this._n = Math.max(0, n);\n    },\n    _handleValue: function _handleValue(x) {\n      if (this._n === 0) {\n        this._emitValue(x);\n      } else {\n        this._n--;\n      }\n    }\n  };\n  var S$13 = createStream('skip', mixin$6);\n  var P$9 = createProperty('skip', mixin$6);\n\n  function skip(obs, n) {\n    return new (obs._ofSameType(S$13, P$9))(obs, {\n      n: n\n    });\n  }\n\n  var mixin$7 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n\n      if (this._fn !== null && !fn(x)) {\n        this._fn = null;\n      }\n\n      if (this._fn === null) {\n        this._emitValue(x);\n      }\n    }\n  };\n  var S$14 = createStream('skipWhile', mixin$7);\n  var P$10 = createProperty('skipWhile', mixin$7);\n\n  var id$3 = function id$3(x) {\n    return x;\n  };\n\n  function skipWhile(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;\n    return new (obs._ofSameType(S$14, P$10))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$8 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n      this._prev = NOTHING;\n    },\n    _free: function _free() {\n      this._fn = null;\n      this._prev = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n\n      if (this._prev === NOTHING || !fn(this._prev, x)) {\n        this._prev = x;\n\n        this._emitValue(x);\n      }\n    }\n  };\n  var S$15 = createStream('skipDuplicates', mixin$8);\n  var P$11 = createProperty('skipDuplicates', mixin$8);\n\n  var eq = function eq(a, b) {\n    return a === b;\n  };\n\n  function skipDuplicates(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;\n    return new (obs._ofSameType(S$15, P$11))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$9 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn,\n          seed = _ref.seed;\n      this._fn = fn;\n      this._prev = seed;\n    },\n    _free: function _free() {\n      this._prev = null;\n      this._fn = null;\n    },\n    _handleValue: function _handleValue(x) {\n      if (this._prev !== NOTHING) {\n        var fn = this._fn;\n\n        this._emitValue(fn(this._prev, x));\n      }\n\n      this._prev = x;\n    }\n  };\n  var S$16 = createStream('diff', mixin$9);\n  var P$12 = createProperty('diff', mixin$9);\n\n  function defaultFn(a, b) {\n    return [a, b];\n  }\n\n  function diff(obs, fn) {\n    var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n    return new (obs._ofSameType(S$16, P$12))(obs, {\n      fn: fn || defaultFn,\n      seed: seed\n    });\n  }\n\n  var P$13 = createProperty('scan', {\n    _init: function _init(_ref) {\n      var fn = _ref.fn,\n          seed = _ref.seed;\n      this._fn = fn;\n      this._seed = seed;\n\n      if (seed !== NOTHING) {\n        this._emitValue(seed);\n      }\n    },\n    _free: function _free() {\n      this._fn = null;\n      this._seed = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n\n      if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n        this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n      } else {\n        this._emitValue(fn(this._currentEvent.value, x));\n      }\n    }\n  });\n\n  function scan(obs, fn) {\n    var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n    return new P$13(obs, {\n      fn: fn,\n      seed: seed\n    });\n  }\n\n  var mixin$10 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n      var xs = fn(x);\n\n      for (var i = 0; i < xs.length; i++) {\n        this._emitValue(xs[i]);\n      }\n    }\n  };\n  var S$17 = createStream('flatten', mixin$10);\n\n  var id$4 = function id$4(x) {\n    return x;\n  };\n\n  function flatten(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;\n    return new S$17(obs, {\n      fn: fn\n    });\n  }\n\n  var END_MARKER = {};\n  var mixin$11 = {\n    _init: function _init(_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n      this._wait = Math.max(0, wait);\n      this._buff = [];\n\n      this._$shiftBuff = function () {\n        var value = _this._buff.shift();\n\n        if (value === END_MARKER) {\n          _this._emitEnd();\n        } else {\n          _this._emitValue(value);\n        }\n      };\n    },\n    _free: function _free() {\n      this._buff = null;\n      this._$shiftBuff = null;\n    },\n    _handleValue: function _handleValue(x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        this._buff.push(x);\n\n        setTimeout(this._$shiftBuff, this._wait);\n      }\n    },\n    _handleEnd: function _handleEnd() {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        this._buff.push(END_MARKER);\n\n        setTimeout(this._$shiftBuff, this._wait);\n      }\n    }\n  };\n  var S$18 = createStream('delay', mixin$11);\n  var P$14 = createProperty('delay', mixin$11);\n\n  function delay(obs, wait) {\n    return new (obs._ofSameType(S$18, P$14))(obs, {\n      wait: wait\n    });\n  }\n\n  var now = Date.now ? function () {\n    return Date.now();\n  } : function () {\n    return new Date().getTime();\n  };\n  var mixin$12 = {\n    _init: function _init(_ref) {\n      var _this = this;\n\n      var wait = _ref.wait,\n          leading = _ref.leading,\n          trailing = _ref.trailing;\n      this._wait = Math.max(0, wait);\n      this._leading = leading;\n      this._trailing = trailing;\n      this._trailingValue = null;\n      this._timeoutId = null;\n      this._endLater = false;\n      this._lastCallTime = 0;\n\n      this._$trailingCall = function () {\n        return _this._trailingCall();\n      };\n    },\n    _free: function _free() {\n      this._trailingValue = null;\n      this._$trailingCall = null;\n    },\n    _handleValue: function _handleValue(x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        var curTime = now();\n\n        if (this._lastCallTime === 0 && !this._leading) {\n          this._lastCallTime = curTime;\n        }\n\n        var remaining = this._wait - (curTime - this._lastCallTime);\n\n        if (remaining <= 0) {\n          this._cancelTrailing();\n\n          this._lastCallTime = curTime;\n\n          this._emitValue(x);\n        } else if (this._trailing) {\n          this._cancelTrailing();\n\n          this._trailingValue = x;\n          this._timeoutId = setTimeout(this._$trailingCall, remaining);\n        }\n      }\n    },\n    _handleEnd: function _handleEnd() {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        if (this._timeoutId) {\n          this._endLater = true;\n        } else {\n          this._emitEnd();\n        }\n      }\n    },\n    _cancelTrailing: function _cancelTrailing() {\n      if (this._timeoutId !== null) {\n        clearTimeout(this._timeoutId);\n        this._timeoutId = null;\n      }\n    },\n    _trailingCall: function _trailingCall() {\n      this._emitValue(this._trailingValue);\n\n      this._timeoutId = null;\n      this._trailingValue = null;\n      this._lastCallTime = !this._leading ? 0 : now();\n\n      if (this._endLater) {\n        this._emitEnd();\n      }\n    }\n  };\n  var S$19 = createStream('throttle', mixin$12);\n  var P$15 = createProperty('throttle', mixin$12);\n\n  function throttle(obs, wait) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$leading = _ref2.leading,\n        leading = _ref2$leading === undefined ? true : _ref2$leading,\n        _ref2$trailing = _ref2.trailing,\n        trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n    return new (obs._ofSameType(S$19, P$15))(obs, {\n      wait: wait,\n      leading: leading,\n      trailing: trailing\n    });\n  }\n\n  var mixin$13 = {\n    _init: function _init(_ref) {\n      var _this = this;\n\n      var wait = _ref.wait,\n          immediate = _ref.immediate;\n      this._wait = Math.max(0, wait);\n      this._immediate = immediate;\n      this._lastAttempt = 0;\n      this._timeoutId = null;\n      this._laterValue = null;\n      this._endLater = false;\n\n      this._$later = function () {\n        return _this._later();\n      };\n    },\n    _free: function _free() {\n      this._laterValue = null;\n      this._$later = null;\n    },\n    _handleValue: function _handleValue(x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        this._lastAttempt = now();\n\n        if (this._immediate && !this._timeoutId) {\n          this._emitValue(x);\n        }\n\n        if (!this._timeoutId) {\n          this._timeoutId = setTimeout(this._$later, this._wait);\n        }\n\n        if (!this._immediate) {\n          this._laterValue = x;\n        }\n      }\n    },\n    _handleEnd: function _handleEnd() {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        if (this._timeoutId && !this._immediate) {\n          this._endLater = true;\n        } else {\n          this._emitEnd();\n        }\n      }\n    },\n    _later: function _later() {\n      var last = now() - this._lastAttempt;\n\n      if (last < this._wait && last >= 0) {\n        this._timeoutId = setTimeout(this._$later, this._wait - last);\n      } else {\n        this._timeoutId = null;\n\n        if (!this._immediate) {\n          this._emitValue(this._laterValue);\n\n          this._laterValue = null;\n        }\n\n        if (this._endLater) {\n          this._emitEnd();\n        }\n      }\n    }\n  };\n  var S$20 = createStream('debounce', mixin$13);\n  var P$16 = createProperty('debounce', mixin$13);\n\n  function debounce(obs, wait) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$immediate = _ref2.immediate,\n        immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n    return new (obs._ofSameType(S$20, P$16))(obs, {\n      wait: wait,\n      immediate: immediate\n    });\n  }\n\n  var mixin$14 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleError: function _handleError(x) {\n      var fn = this._fn;\n\n      this._emitError(fn(x));\n    }\n  };\n  var S$21 = createStream('mapErrors', mixin$14);\n  var P$17 = createProperty('mapErrors', mixin$14);\n\n  var id$5 = function id$5(x) {\n    return x;\n  };\n\n  function mapErrors(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;\n    return new (obs._ofSameType(S$21, P$17))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$15 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleError: function _handleError(x) {\n      var fn = this._fn;\n\n      if (fn(x)) {\n        this._emitError(x);\n      }\n    }\n  };\n  var S$22 = createStream('filterErrors', mixin$15);\n  var P$18 = createProperty('filterErrors', mixin$15);\n\n  var id$6 = function id$6(x) {\n    return x;\n  };\n\n  function filterErrors(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;\n    return new (obs._ofSameType(S$22, P$18))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$16 = {\n    _handleValue: function _handleValue() {}\n  };\n  var S$23 = createStream('ignoreValues', mixin$16);\n  var P$19 = createProperty('ignoreValues', mixin$16);\n\n  function ignoreValues(obs) {\n    return new (obs._ofSameType(S$23, P$19))(obs);\n  }\n\n  var mixin$17 = {\n    _handleError: function _handleError() {}\n  };\n  var S$24 = createStream('ignoreErrors', mixin$17);\n  var P$20 = createProperty('ignoreErrors', mixin$17);\n\n  function ignoreErrors(obs) {\n    return new (obs._ofSameType(S$24, P$20))(obs);\n  }\n\n  var mixin$18 = {\n    _handleEnd: function _handleEnd() {}\n  };\n  var S$25 = createStream('ignoreEnd', mixin$18);\n  var P$21 = createProperty('ignoreEnd', mixin$18);\n\n  function ignoreEnd(obs) {\n    return new (obs._ofSameType(S$25, P$21))(obs);\n  }\n\n  var mixin$19 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleEnd: function _handleEnd() {\n      var fn = this._fn;\n\n      this._emitValue(fn());\n\n      this._emitEnd();\n    }\n  };\n  var S$26 = createStream('beforeEnd', mixin$19);\n  var P$22 = createProperty('beforeEnd', mixin$19);\n\n  function beforeEnd(obs, fn) {\n    return new (obs._ofSameType(S$26, P$22))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$20 = {\n    _init: function _init(_ref) {\n      var min = _ref.min,\n          max = _ref.max;\n      this._max = max;\n      this._min = min;\n      this._buff = [];\n    },\n    _free: function _free() {\n      this._buff = null;\n    },\n    _handleValue: function _handleValue(x) {\n      this._buff = slide(this._buff, x, this._max);\n\n      if (this._buff.length >= this._min) {\n        this._emitValue(this._buff);\n      }\n    }\n  };\n  var S$27 = createStream('slidingWindow', mixin$20);\n  var P$23 = createProperty('slidingWindow', mixin$20);\n\n  function slidingWindow(obs, max) {\n    var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    return new (obs._ofSameType(S$27, P$23))(obs, {\n      min: min,\n      max: max\n    });\n  }\n\n  var mixin$21 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn,\n          flushOnEnd = _ref.flushOnEnd;\n      this._fn = fn;\n      this._flushOnEnd = flushOnEnd;\n      this._buff = [];\n    },\n    _free: function _free() {\n      this._buff = null;\n    },\n    _flush: function _flush() {\n      if (this._buff !== null && this._buff.length !== 0) {\n        this._emitValue(this._buff);\n\n        this._buff = [];\n      }\n    },\n    _handleValue: function _handleValue(x) {\n      this._buff.push(x);\n\n      var fn = this._fn;\n\n      if (!fn(x)) {\n        this._flush();\n      }\n    },\n    _handleEnd: function _handleEnd() {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n\n      this._emitEnd();\n    }\n  };\n  var S$28 = createStream('bufferWhile', mixin$21);\n  var P$24 = createProperty('bufferWhile', mixin$21);\n\n  var id$7 = function id$7(x) {\n    return x;\n  };\n\n  function bufferWhile(obs, fn) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$flushOnEnd = _ref2.flushOnEnd,\n        flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$28, P$24))(obs, {\n      fn: fn || id$7,\n      flushOnEnd: flushOnEnd\n    });\n  }\n\n  var mixin$22 = {\n    _init: function _init(_ref) {\n      var count = _ref.count,\n          flushOnEnd = _ref.flushOnEnd;\n      this._count = count;\n      this._flushOnEnd = flushOnEnd;\n      this._buff = [];\n    },\n    _free: function _free() {\n      this._buff = null;\n    },\n    _flush: function _flush() {\n      if (this._buff !== null && this._buff.length !== 0) {\n        this._emitValue(this._buff);\n\n        this._buff = [];\n      }\n    },\n    _handleValue: function _handleValue(x) {\n      this._buff.push(x);\n\n      if (this._buff.length >= this._count) {\n        this._flush();\n      }\n    },\n    _handleEnd: function _handleEnd() {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n\n      this._emitEnd();\n    }\n  };\n  var S$29 = createStream('bufferWithCount', mixin$22);\n  var P$25 = createProperty('bufferWithCount', mixin$22);\n\n  function bufferWhile$1(obs, count) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$flushOnEnd = _ref2.flushOnEnd,\n        flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$29, P$25))(obs, {\n      count: count,\n      flushOnEnd: flushOnEnd\n    });\n  }\n\n  var mixin$23 = {\n    _init: function _init(_ref) {\n      var _this = this;\n\n      var wait = _ref.wait,\n          count = _ref.count,\n          flushOnEnd = _ref.flushOnEnd;\n      this._wait = wait;\n      this._count = count;\n      this._flushOnEnd = flushOnEnd;\n      this._intervalId = null;\n\n      this._$onTick = function () {\n        return _this._flush();\n      };\n\n      this._buff = [];\n    },\n    _free: function _free() {\n      this._$onTick = null;\n      this._buff = null;\n    },\n    _flush: function _flush() {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n\n        this._buff = [];\n      }\n    },\n    _handleValue: function _handleValue(x) {\n      this._buff.push(x);\n\n      if (this._buff.length >= this._count) {\n        clearInterval(this._intervalId);\n\n        this._flush();\n\n        this._intervalId = setInterval(this._$onTick, this._wait);\n      }\n    },\n    _handleEnd: function _handleEnd() {\n      if (this._flushOnEnd && this._buff.length !== 0) {\n        this._flush();\n      }\n\n      this._emitEnd();\n    },\n    _onActivation: function _onActivation() {\n      this._intervalId = setInterval(this._$onTick, this._wait);\n\n      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\n    },\n    _onDeactivation: function _onDeactivation() {\n      if (this._intervalId !== null) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n\n      this._source.offAny(this._$handleAny); // copied from patterns/one-source\n\n    }\n  };\n  var S$30 = createStream('bufferWithTimeOrCount', mixin$23);\n  var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\n  function bufferWithTimeOrCount(obs, wait, count) {\n    var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref2$flushOnEnd = _ref2.flushOnEnd,\n        flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$30, P$26))(obs, {\n      wait: wait,\n      count: count,\n      flushOnEnd: flushOnEnd\n    });\n  }\n\n  function xformForObs(obs) {\n    return {\n      '@@transducer/step': function transducerStep(res, input) {\n        obs._emitValue(input);\n\n        return null;\n      },\n      '@@transducer/result': function transducerResult() {\n        obs._emitEnd();\n\n        return null;\n      }\n    };\n  }\n\n  var mixin$24 = {\n    _init: function _init(_ref) {\n      var transducer = _ref.transducer;\n      this._xform = transducer(xformForObs(this));\n    },\n    _free: function _free() {\n      this._xform = null;\n    },\n    _handleValue: function _handleValue(x) {\n      if (this._xform['@@transducer/step'](null, x) !== null) {\n        this._xform['@@transducer/result'](null);\n      }\n    },\n    _handleEnd: function _handleEnd() {\n      this._xform['@@transducer/result'](null);\n    }\n  };\n  var S$31 = createStream('transduce', mixin$24);\n  var P$27 = createProperty('transduce', mixin$24);\n\n  function transduce(obs, transducer) {\n    return new (obs._ofSameType(S$31, P$27))(obs, {\n      transducer: transducer\n    });\n  }\n\n  var mixin$25 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._handler = fn;\n      this._emitter = emitter(this);\n    },\n    _free: function _free() {\n      this._handler = null;\n      this._emitter = null;\n    },\n    _handleAny: function _handleAny(event) {\n      this._handler(this._emitter, event);\n    }\n  };\n  var S$32 = createStream('withHandler', mixin$25);\n  var P$28 = createProperty('withHandler', mixin$25);\n\n  function withHandler(obs, fn) {\n    return new (obs._ofSameType(S$32, P$28))(obs, {\n      fn: fn\n    });\n  }\n\n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n\n  function Zip(sources, combinator) {\n    var _this = this;\n\n    Stream.call(this);\n    this._buffers = map(sources, function (source) {\n      return isArray(source) ? cloneArray(source) : [];\n    });\n    this._sources = map(sources, function (source) {\n      return isArray(source) ? never() : source;\n    });\n    this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n      return x;\n    };\n    this._aliveCount = 0;\n    this._$handlers = [];\n\n    var _loop = function _loop(i) {\n      _this._$handlers.push(function (event) {\n        return _this._handleAny(i, event);\n      });\n    };\n\n    for (var i = 0; i < this._sources.length; i++) {\n      _loop(i);\n    }\n  }\n\n  inherit(Zip, Stream, {\n    _name: 'zip',\n    _onActivation: function _onActivation() {\n      // if all sources are arrays\n      while (this._isFull()) {\n        this._emit();\n      }\n\n      var length = this._sources.length;\n      this._aliveCount = length;\n\n      for (var i = 0; i < length && this._active; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n    },\n    _onDeactivation: function _onDeactivation() {\n      for (var i = 0; i < this._sources.length; i++) {\n        this._sources[i].offAny(this._$handlers[i]);\n      }\n    },\n    _emit: function _emit() {\n      var values = new Array(this._buffers.length);\n\n      for (var i = 0; i < this._buffers.length; i++) {\n        values[i] = this._buffers[i].shift();\n      }\n\n      var combinator = this._combinator;\n\n      this._emitValue(combinator(values));\n    },\n    _isFull: function _isFull() {\n      for (var i = 0; i < this._buffers.length; i++) {\n        if (this._buffers[i].length === 0) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    _handleAny: function _handleAny(i, event) {\n      if (event.type === VALUE) {\n        this._buffers[i].push(event.value);\n\n        if (this._isFull()) {\n          this._emit();\n        }\n      }\n\n      if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n\n      if (event.type === END) {\n        this._aliveCount--;\n\n        if (this._aliveCount === 0) {\n          this._emitEnd();\n        }\n      }\n    },\n    _clear: function _clear() {\n      Stream.prototype._clear.call(this);\n\n      this._sources = null;\n      this._buffers = null;\n      this._combinator = null;\n      this._$handlers = null;\n    }\n  });\n\n  function zip(observables, combinator\n  /* Function | falsey */\n  ) {\n    return observables.length === 0 ? never() : new Zip(observables, combinator);\n  }\n\n  var id$8 = function id$8(x) {\n    return x;\n  };\n\n  function AbstractPool() {\n    var _this = this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$queueLim = _ref.queueLim,\n        queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,\n        _ref$concurLim = _ref.concurLim,\n        concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,\n        _ref$drop = _ref.drop,\n        drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n    Stream.call(this);\n    this._queueLim = queueLim < 0 ? -1 : queueLim;\n    this._concurLim = concurLim < 0 ? -1 : concurLim;\n    this._drop = drop;\n    this._queue = [];\n    this._curSources = [];\n\n    this._$handleSubAny = function (event) {\n      return _this._handleSubAny(event);\n    };\n\n    this._$endHandlers = [];\n    this._currentlyAdding = null;\n\n    if (this._concurLim === 0) {\n      this._emitEnd();\n    }\n  }\n\n  inherit(AbstractPool, Stream, {\n    _name: 'abstractPool',\n    _add: function _add(obj, toObs\n    /* Function | falsey */\n    ) {\n      toObs = toObs || id$8;\n\n      if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n        this._addToCur(toObs(obj));\n      } else {\n        if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n          this._addToQueue(toObs(obj));\n        } else if (this._drop === 'old') {\n          this._removeOldest();\n\n          this._add(obj, toObs);\n        }\n      }\n    },\n    _addAll: function _addAll(obss) {\n      var _this2 = this;\n\n      forEach(obss, function (obs) {\n        return _this2._add(obs);\n      });\n    },\n    _remove: function _remove(obs) {\n      if (this._removeCur(obs) === -1) {\n        this._removeQueue(obs);\n      }\n    },\n    _addToQueue: function _addToQueue(obs) {\n      this._queue = concat(this._queue, [obs]);\n    },\n    _addToCur: function _addToCur(obs) {\n      if (this._active) {\n        // HACK:\n        //\n        // We have two optimizations for cases when `obs` is ended. We don't want\n        // to add such observable to the list, but only want to emit events\n        // from it (if it has some).\n        //\n        // Instead of this hacks, we could just did following,\n        // but it would be 5-8 times slower:\n        //\n        //     this._curSources = concat(this._curSources, [obs]);\n        //     this._subscribe(obs);\n        //\n        // #1\n        // This one for cases when `obs` already ended\n        // e.g., Kefir.constant() or Kefir.never()\n        if (!obs._alive) {\n          if (obs._currentEvent) {\n            this._emit(obs._currentEvent.type, obs._currentEvent.value);\n          } // The _emit above could have caused this stream to end.\n\n\n          if (this._active) {\n            if (this._queue.length !== 0) {\n              this._pullQueue();\n            } else if (this._curSources.length === 0) {\n              this._onEmpty();\n            }\n          }\n\n          return;\n        } // #2\n        // This one is for cases when `obs` going to end synchronously on\n        // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n\n\n        this._currentlyAdding = obs;\n        obs.onAny(this._$handleSubAny);\n        this._currentlyAdding = null;\n\n        if (obs._alive) {\n          this._curSources = concat(this._curSources, [obs]);\n\n          if (this._active) {\n            this._subToEnd(obs);\n          }\n        }\n      } else {\n        this._curSources = concat(this._curSources, [obs]);\n      }\n    },\n    _subToEnd: function _subToEnd(obs) {\n      var _this3 = this;\n\n      var onEnd = function onEnd() {\n        return _this3._removeCur(obs);\n      };\n\n      this._$endHandlers.push({\n        obs: obs,\n        handler: onEnd\n      });\n\n      obs.onEnd(onEnd);\n    },\n    _subscribe: function _subscribe(obs) {\n      obs.onAny(this._$handleSubAny); // it can become inactive in responce of subscribing to `obs.onAny` above\n\n      if (this._active) {\n        this._subToEnd(obs);\n      }\n    },\n    _unsubscribe: function _unsubscribe(obs) {\n      obs.offAny(this._$handleSubAny);\n      var onEndI = findByPred(this._$endHandlers, function (obj) {\n        return obj.obs === obs;\n      });\n\n      if (onEndI !== -1) {\n        obs.offEnd(this._$endHandlers[onEndI].handler);\n\n        this._$endHandlers.splice(onEndI, 1);\n      }\n    },\n    _handleSubAny: function _handleSubAny(event) {\n      if (event.type === VALUE) {\n        this._emitValue(event.value);\n      } else if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n    },\n    _removeQueue: function _removeQueue(obs) {\n      var index = find(this._queue, obs);\n      this._queue = _remove(this._queue, index);\n      return index;\n    },\n    _removeCur: function _removeCur(obs) {\n      if (this._active) {\n        this._unsubscribe(obs);\n      }\n\n      var index = find(this._curSources, obs);\n      this._curSources = _remove(this._curSources, index);\n\n      if (index !== -1) {\n        if (this._queue.length !== 0) {\n          this._pullQueue();\n        } else if (this._curSources.length === 0) {\n          this._onEmpty();\n        }\n      }\n\n      return index;\n    },\n    _removeOldest: function _removeOldest() {\n      this._removeCur(this._curSources[0]);\n    },\n    _pullQueue: function _pullQueue() {\n      if (this._queue.length !== 0) {\n        this._queue = cloneArray(this._queue);\n\n        this._addToCur(this._queue.shift());\n      }\n    },\n    _onActivation: function _onActivation() {\n      for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n        this._subscribe(sources[i]);\n      }\n    },\n    _onDeactivation: function _onDeactivation() {\n      for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n        this._unsubscribe(sources[i]);\n      }\n\n      if (this._currentlyAdding !== null) {\n        this._unsubscribe(this._currentlyAdding);\n      }\n    },\n    _isEmpty: function _isEmpty() {\n      return this._curSources.length === 0;\n    },\n    _onEmpty: function _onEmpty() {},\n    _clear: function _clear() {\n      Stream.prototype._clear.call(this);\n\n      this._queue = null;\n      this._curSources = null;\n      this._$handleSubAny = null;\n      this._$endHandlers = null;\n    }\n  });\n\n  function Merge(sources) {\n    AbstractPool.call(this);\n\n    this._addAll(sources);\n\n    this._initialised = true;\n  }\n\n  inherit(Merge, AbstractPool, {\n    _name: 'merge',\n    _onEmpty: function _onEmpty() {\n      if (this._initialised) {\n        this._emitEnd();\n      }\n    }\n  });\n\n  function merge(observables) {\n    return observables.length === 0 ? never() : new Merge(observables);\n  }\n\n  function S$33(generator) {\n    var _this = this;\n\n    Stream.call(this);\n    this._generator = generator;\n    this._source = null;\n    this._inLoop = false;\n    this._iteration = 0;\n\n    this._$handleAny = function (event) {\n      return _this._handleAny(event);\n    };\n  }\n\n  inherit(S$33, Stream, {\n    _name: 'repeat',\n    _handleAny: function _handleAny(event) {\n      if (event.type === END) {\n        this._source = null;\n\n        this._getSource();\n      } else {\n        this._emit(event.type, event.value);\n      }\n    },\n    _getSource: function _getSource() {\n      if (!this._inLoop) {\n        this._inLoop = true;\n        var generator = this._generator;\n\n        while (this._source === null && this._alive && this._active) {\n          this._source = generator(this._iteration++);\n\n          if (this._source) {\n            this._source.onAny(this._$handleAny);\n          } else {\n            this._emitEnd();\n          }\n        }\n\n        this._inLoop = false;\n      }\n    },\n    _onActivation: function _onActivation() {\n      if (this._source) {\n        this._source.onAny(this._$handleAny);\n      } else {\n        this._getSource();\n      }\n    },\n    _onDeactivation: function _onDeactivation() {\n      if (this._source) {\n        this._source.offAny(this._$handleAny);\n      }\n    },\n    _clear: function _clear() {\n      Stream.prototype._clear.call(this);\n\n      this._generator = null;\n      this._source = null;\n      this._$handleAny = null;\n    }\n  });\n\n  var repeat = function repeat(generator) {\n    return new S$33(generator);\n  };\n\n  function concat$1(observables) {\n    return repeat(function (index) {\n      return observables.length > index ? observables[index] : false;\n    }).setName('concat');\n  }\n\n  function Pool() {\n    AbstractPool.call(this);\n  }\n\n  inherit(Pool, AbstractPool, {\n    _name: 'pool',\n    plug: function plug(obs) {\n      this._add(obs);\n\n      return this;\n    },\n    unplug: function unplug(obs) {\n      this._remove(obs);\n\n      return this;\n    }\n  });\n\n  function FlatMap(source, fn, options) {\n    var _this = this;\n\n    AbstractPool.call(this, options);\n    this._source = source;\n    this._fn = fn;\n    this._mainEnded = false;\n    this._lastCurrent = null;\n\n    this._$handleMain = function (event) {\n      return _this._handleMain(event);\n    };\n  }\n\n  inherit(FlatMap, AbstractPool, {\n    _onActivation: function _onActivation() {\n      AbstractPool.prototype._onActivation.call(this);\n\n      if (this._active) {\n        this._source.onAny(this._$handleMain);\n      }\n    },\n    _onDeactivation: function _onDeactivation() {\n      AbstractPool.prototype._onDeactivation.call(this);\n\n      this._source.offAny(this._$handleMain);\n\n      this._hadNoEvSinceDeact = true;\n    },\n    _handleMain: function _handleMain(event) {\n      if (event.type === VALUE) {\n        // Is latest value before deactivation survived, and now is 'current' on this activation?\n        // We don't want to handle such values, to prevent to constantly add\n        // same observale on each activation/deactivation when our main source\n        // is a `Kefir.conatant()` for example.\n        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\n        if (!sameCurr) {\n          this._add(event.value, this._fn);\n        }\n\n        this._lastCurrent = event.value;\n        this._hadNoEvSinceDeact = false;\n      }\n\n      if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n\n      if (event.type === END) {\n        if (this._isEmpty()) {\n          this._emitEnd();\n        } else {\n          this._mainEnded = true;\n        }\n      }\n    },\n    _onEmpty: function _onEmpty() {\n      if (this._mainEnded) {\n        this._emitEnd();\n      }\n    },\n    _clear: function _clear() {\n      AbstractPool.prototype._clear.call(this);\n\n      this._source = null;\n      this._lastCurrent = null;\n      this._$handleMain = null;\n    }\n  });\n\n  function FlatMapErrors(source, fn) {\n    FlatMap.call(this, source, fn);\n  }\n\n  inherit(FlatMapErrors, FlatMap, {\n    // Same as in FlatMap, only VALUE/ERROR flipped\n    _handleMain: function _handleMain(event) {\n      if (event.type === ERROR) {\n        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\n        if (!sameCurr) {\n          this._add(event.value, this._fn);\n        }\n\n        this._lastCurrent = event.value;\n        this._hadNoEvSinceDeact = false;\n      }\n\n      if (event.type === VALUE) {\n        this._emitValue(event.value);\n      }\n\n      if (event.type === END) {\n        if (this._isEmpty()) {\n          this._emitEnd();\n        } else {\n          this._mainEnded = true;\n        }\n      }\n    }\n  });\n\n  function createConstructor$1(BaseClass, name) {\n    return function AnonymousObservable(primary, secondary, options) {\n      var _this = this;\n\n      BaseClass.call(this);\n      this._primary = primary;\n      this._secondary = secondary;\n      this._name = primary._name + '.' + name;\n      this._lastSecondary = NOTHING;\n\n      this._$handleSecondaryAny = function (event) {\n        return _this._handleSecondaryAny(event);\n      };\n\n      this._$handlePrimaryAny = function (event) {\n        return _this._handlePrimaryAny(event);\n      };\n\n      this._init(options);\n    };\n  }\n\n  function createClassMethods$1(BaseClass) {\n    return {\n      _init: function _init() {},\n      _free: function _free() {},\n      _handlePrimaryValue: function _handlePrimaryValue(x) {\n        this._emitValue(x);\n      },\n      _handlePrimaryError: function _handlePrimaryError(x) {\n        this._emitError(x);\n      },\n      _handlePrimaryEnd: function _handlePrimaryEnd() {\n        this._emitEnd();\n      },\n      _handleSecondaryValue: function _handleSecondaryValue(x) {\n        this._lastSecondary = x;\n      },\n      _handleSecondaryError: function _handleSecondaryError(x) {\n        this._emitError(x);\n      },\n      _handleSecondaryEnd: function _handleSecondaryEnd() {},\n      _handlePrimaryAny: function _handlePrimaryAny(event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handlePrimaryValue(event.value);\n\n          case ERROR:\n            return this._handlePrimaryError(event.value);\n\n          case END:\n            return this._handlePrimaryEnd(event.value);\n        }\n      },\n      _handleSecondaryAny: function _handleSecondaryAny(event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handleSecondaryValue(event.value);\n\n          case ERROR:\n            return this._handleSecondaryError(event.value);\n\n          case END:\n            this._handleSecondaryEnd(event.value);\n\n            this._removeSecondary();\n\n        }\n      },\n      _removeSecondary: function _removeSecondary() {\n        if (this._secondary !== null) {\n          this._secondary.offAny(this._$handleSecondaryAny);\n\n          this._$handleSecondaryAny = null;\n          this._secondary = null;\n        }\n      },\n      _onActivation: function _onActivation() {\n        if (this._secondary !== null) {\n          this._secondary.onAny(this._$handleSecondaryAny);\n        }\n\n        if (this._active) {\n          this._primary.onAny(this._$handlePrimaryAny);\n        }\n      },\n      _onDeactivation: function _onDeactivation() {\n        if (this._secondary !== null) {\n          this._secondary.offAny(this._$handleSecondaryAny);\n        }\n\n        this._primary.offAny(this._$handlePrimaryAny);\n      },\n      _clear: function _clear() {\n        BaseClass.prototype._clear.call(this);\n\n        this._primary = null;\n        this._secondary = null;\n        this._lastSecondary = null;\n        this._$handleSecondaryAny = null;\n        this._$handlePrimaryAny = null;\n\n        this._free();\n      }\n    };\n  }\n\n  function createStream$1(name, mixin) {\n    var S = createConstructor$1(Stream, name);\n    inherit(S, Stream, createClassMethods$1(Stream), mixin);\n    return S;\n  }\n\n  function createProperty$1(name, mixin) {\n    var P = createConstructor$1(Property, name);\n    inherit(P, Property, createClassMethods$1(Property), mixin);\n    return P;\n  }\n\n  var mixin$26 = {\n    _handlePrimaryValue: function _handlePrimaryValue(x) {\n      if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n        this._emitValue(x);\n      }\n    },\n    _handleSecondaryEnd: function _handleSecondaryEnd() {\n      if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n        this._emitEnd();\n      }\n    }\n  };\n  var S$34 = createStream$1('filterBy', mixin$26);\n  var P$29 = createProperty$1('filterBy', mixin$26);\n\n  function filterBy(primary, secondary) {\n    return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n  }\n\n  var id2 = function id2(_, x) {\n    return x;\n  };\n\n  function sampledBy(passive, active, combinator) {\n    var _combinator = combinator ? function (a, b) {\n      return combinator(b, a);\n    } : id2;\n\n    return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n  }\n\n  var mixin$27 = {\n    _handlePrimaryValue: function _handlePrimaryValue(x) {\n      if (this._lastSecondary !== NOTHING) {\n        this._emitValue(x);\n      }\n    },\n    _handleSecondaryEnd: function _handleSecondaryEnd() {\n      if (this._lastSecondary === NOTHING) {\n        this._emitEnd();\n      }\n    }\n  };\n  var S$35 = createStream$1('skipUntilBy', mixin$27);\n  var P$30 = createProperty$1('skipUntilBy', mixin$27);\n\n  function skipUntilBy(primary, secondary) {\n    return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n  }\n\n  var mixin$28 = {\n    _handleSecondaryValue: function _handleSecondaryValue() {\n      this._emitEnd();\n    }\n  };\n  var S$36 = createStream$1('takeUntilBy', mixin$28);\n  var P$31 = createProperty$1('takeUntilBy', mixin$28);\n\n  function takeUntilBy(primary, secondary) {\n    return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n  }\n\n  var mixin$29 = {\n    _init: function _init() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$flushOnEnd = _ref.flushOnEnd,\n          flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n      this._buff = [];\n      this._flushOnEnd = flushOnEnd;\n    },\n    _free: function _free() {\n      this._buff = null;\n    },\n    _flush: function _flush() {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n\n        this._buff = [];\n      }\n    },\n    _handlePrimaryEnd: function _handlePrimaryEnd() {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n\n      this._emitEnd();\n    },\n    _onActivation: function _onActivation() {\n      this._primary.onAny(this._$handlePrimaryAny);\n\n      if (this._alive && this._secondary !== null) {\n        this._secondary.onAny(this._$handleSecondaryAny);\n      }\n    },\n    _handlePrimaryValue: function _handlePrimaryValue(x) {\n      this._buff.push(x);\n    },\n    _handleSecondaryValue: function _handleSecondaryValue() {\n      this._flush();\n    },\n    _handleSecondaryEnd: function _handleSecondaryEnd() {\n      if (!this._flushOnEnd) {\n        this._emitEnd();\n      }\n    }\n  };\n  var S$37 = createStream$1('bufferBy', mixin$29);\n  var P$32 = createProperty$1('bufferBy', mixin$29);\n\n  function bufferBy(primary, secondary, options\n  /* optional */\n  ) {\n    return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n  }\n\n  var mixin$30 = {\n    _init: function _init() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$flushOnEnd = _ref.flushOnEnd,\n          flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,\n          _ref$flushOnChange = _ref.flushOnChange,\n          flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n      this._buff = [];\n      this._flushOnEnd = flushOnEnd;\n      this._flushOnChange = flushOnChange;\n    },\n    _free: function _free() {\n      this._buff = null;\n    },\n    _flush: function _flush() {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n\n        this._buff = [];\n      }\n    },\n    _handlePrimaryEnd: function _handlePrimaryEnd() {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n\n      this._emitEnd();\n    },\n    _handlePrimaryValue: function _handlePrimaryValue(x) {\n      this._buff.push(x);\n\n      if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n        this._flush();\n      }\n    },\n    _handleSecondaryEnd: function _handleSecondaryEnd() {\n      if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n        this._emitEnd();\n      }\n    },\n    _handleSecondaryValue: function _handleSecondaryValue(x) {\n      if (this._flushOnChange && !x) {\n        this._flush();\n      } // from default _handleSecondaryValue\n\n\n      this._lastSecondary = x;\n    }\n  };\n  var S$38 = createStream$1('bufferWhileBy', mixin$30);\n  var P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\n  function bufferWhileBy(primary, secondary, options\n  /* optional */\n  ) {\n    return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n  }\n\n  var f = function f() {\n    return false;\n  };\n\n  var t = function t() {\n    return true;\n  };\n\n  function awaiting(a, b) {\n    var result = merge([map$1(a, t), map$1(b, f)]);\n    result = skipDuplicates(result);\n    result = toProperty(result, f);\n    return result.setName(a, 'awaiting');\n  }\n\n  var mixin$31 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleValue: function _handleValue(x) {\n      var fn = this._fn;\n      var result = fn(x);\n\n      if (result.convert) {\n        this._emitError(result.error);\n      } else {\n        this._emitValue(x);\n      }\n    }\n  };\n  var S$39 = createStream('valuesToErrors', mixin$31);\n  var P$34 = createProperty('valuesToErrors', mixin$31);\n\n  var defFn = function defFn(x) {\n    return {\n      convert: true,\n      error: x\n    };\n  };\n\n  function valuesToErrors(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;\n    return new (obs._ofSameType(S$39, P$34))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$32 = {\n    _init: function _init(_ref) {\n      var fn = _ref.fn;\n      this._fn = fn;\n    },\n    _free: function _free() {\n      this._fn = null;\n    },\n    _handleError: function _handleError(x) {\n      var fn = this._fn;\n      var result = fn(x);\n\n      if (result.convert) {\n        this._emitValue(result.value);\n      } else {\n        this._emitError(x);\n      }\n    }\n  };\n  var S$40 = createStream('errorsToValues', mixin$32);\n  var P$35 = createProperty('errorsToValues', mixin$32);\n\n  var defFn$1 = function defFn$1(x) {\n    return {\n      convert: true,\n      value: x\n    };\n  };\n\n  function errorsToValues(obs) {\n    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;\n    return new (obs._ofSameType(S$40, P$35))(obs, {\n      fn: fn\n    });\n  }\n\n  var mixin$33 = {\n    _handleError: function _handleError(x) {\n      this._emitError(x);\n\n      this._emitEnd();\n    }\n  };\n  var S$41 = createStream('endOnError', mixin$33);\n  var P$36 = createProperty('endOnError', mixin$33);\n\n  function endOnError(obs) {\n    return new (obs._ofSameType(S$41, P$36))(obs);\n  } // Create a stream\n  // -----------------------------------------------------------------------------\n  // () -> Stream\n  // (number, any) -> Stream\n  // (number, any) -> Stream\n  // (number, Array<any>) -> Stream\n  // (number, Function) -> Stream\n  // (number, Function) -> Stream\n  // (Function) -> Stream\n  // (Function) -> Stream\n  // Target = {addEventListener, removeEventListener}|{addListener, removeListener}|{on, off}\n  // (Target, string, Function|undefined) -> Stream\n  // (Function) -> Stream\n  // Create a property\n  // -----------------------------------------------------------------------------\n  // (any) -> Property\n  // (any) -> Property\n  // Convert observables\n  // -----------------------------------------------------------------------------\n  // (Stream|Property, Function|undefined) -> Property\n\n\n  Observable.prototype.toProperty = function (fn) {\n    return toProperty(this, fn);\n  }; // (Stream|Property) -> Stream\n\n\n  Observable.prototype.changes = function () {\n    return changes(this);\n  }; // Interoperation with other implimentations\n  // -----------------------------------------------------------------------------\n  // (Promise) -> Property\n  // (Stream|Property, Function|undefined) -> Promise\n\n\n  Observable.prototype.toPromise = function (Promise) {\n    return toPromise(this, Promise);\n  }; // (ESObservable) -> Stream\n  // (Stream|Property) -> ES7 Observable\n\n\n  Observable.prototype.toESObservable = toESObservable;\n  Observable.prototype[$$observable] = toESObservable; // Modify an observable\n  // -----------------------------------------------------------------------------\n  // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n  Observable.prototype.map = function (fn) {\n    return map$1(this, fn);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.filter = function (fn) {\n    return filter(this, fn);\n  }; // (Stream, number) -> Stream\n  // (Property, number) -> Property\n\n\n  Observable.prototype.take = function (n) {\n    return take(this, n);\n  }; // (Stream, number) -> Stream\n  // (Property, number) -> Property\n\n\n  Observable.prototype.takeErrors = function (n) {\n    return takeErrors(this, n);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.takeWhile = function (fn) {\n    return takeWhile(this, fn);\n  }; // (Stream) -> Stream\n  // (Property) -> Property\n\n\n  Observable.prototype.last = function () {\n    return last(this);\n  }; // (Stream, number) -> Stream\n  // (Property, number) -> Property\n\n\n  Observable.prototype.skip = function (n) {\n    return skip(this, n);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.skipWhile = function (fn) {\n    return skipWhile(this, fn);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.skipDuplicates = function (fn) {\n    return skipDuplicates(this, fn);\n  }; // (Stream, Function|falsey, any|undefined) -> Stream\n  // (Property, Function|falsey, any|undefined) -> Property\n\n\n  Observable.prototype.diff = function (fn, seed) {\n    return diff(this, fn, seed);\n  }; // (Stream|Property, Function, any|undefined) -> Property\n\n\n  Observable.prototype.scan = function (fn, seed) {\n    return scan(this, fn, seed);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.flatten = function (fn) {\n    return flatten(this, fn);\n  }; // (Stream, number) -> Stream\n  // (Property, number) -> Property\n\n\n  Observable.prototype.delay = function (wait) {\n    return delay(this, wait);\n  }; // Options = {leading: boolean|undefined, trailing: boolean|undefined}\n  // (Stream, number, Options|undefined) -> Stream\n  // (Property, number, Options|undefined) -> Property\n\n\n  Observable.prototype.throttle = function (wait, options) {\n    return throttle(this, wait, options);\n  }; // Options = {immediate: boolean|undefined}\n  // (Stream, number, Options|undefined) -> Stream\n  // (Property, number, Options|undefined) -> Property\n\n\n  Observable.prototype.debounce = function (wait, options) {\n    return debounce(this, wait, options);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.mapErrors = function (fn) {\n    return mapErrors(this, fn);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.filterErrors = function (fn) {\n    return filterErrors(this, fn);\n  }; // (Stream) -> Stream\n  // (Property) -> Property\n\n\n  Observable.prototype.ignoreValues = function () {\n    return ignoreValues(this);\n  }; // (Stream) -> Stream\n  // (Property) -> Property\n\n\n  Observable.prototype.ignoreErrors = function () {\n    return ignoreErrors(this);\n  }; // (Stream) -> Stream\n  // (Property) -> Property\n\n\n  Observable.prototype.ignoreEnd = function () {\n    return ignoreEnd(this);\n  }; // (Stream, Function) -> Stream\n  // (Property, Function) -> Property\n\n\n  Observable.prototype.beforeEnd = function (fn) {\n    return beforeEnd(this, fn);\n  }; // (Stream, number, number|undefined) -> Stream\n  // (Property, number, number|undefined) -> Property\n\n\n  Observable.prototype.slidingWindow = function (max, min) {\n    return slidingWindow(this, max, min);\n  }; // Options = {flushOnEnd: boolean|undefined}\n  // (Stream, Function|falsey, Options|undefined) -> Stream\n  // (Property, Function|falsey, Options|undefined) -> Property\n\n\n  Observable.prototype.bufferWhile = function (fn, options) {\n    return bufferWhile(this, fn, options);\n  }; // (Stream, number) -> Stream\n  // (Property, number) -> Property\n\n\n  Observable.prototype.bufferWithCount = function (count, options) {\n    return bufferWhile$1(this, count, options);\n  }; // Options = {flushOnEnd: boolean|undefined}\n  // (Stream, number, number, Options|undefined) -> Stream\n  // (Property, number, number, Options|undefined) -> Property\n\n\n  Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n    return bufferWithTimeOrCount(this, wait, count, options);\n  }; // (Stream, Function) -> Stream\n  // (Property, Function) -> Property\n\n\n  Observable.prototype.transduce = function (transducer) {\n    return transduce(this, transducer);\n  }; // (Stream, Function) -> Stream\n  // (Property, Function) -> Property\n\n\n  Observable.prototype.withHandler = function (fn) {\n    return withHandler(this, fn);\n  }; // (Stream, Stream -> a) -> a\n  // (Property, Property -> a) -> a\n\n\n  Observable.prototype.thru = function (fn) {\n    return fn(this);\n  }; // Combine observables\n  // -----------------------------------------------------------------------------\n  // (Array<Stream|Property>, Function|undefiend) -> Stream\n  // (Array<Stream|Property>, Array<Stream|Property>, Function|undefiend) -> Stream\n\n\n  Observable.prototype.combine = function (other, combinator) {\n    return combine([this, other], combinator);\n  }; // (Array<Stream|Property>, Function|undefiend) -> Stream\n\n\n  Observable.prototype.zip = function (other, combinator) {\n    return zip([this, other], combinator);\n  }; // (Array<Stream|Property>) -> Stream\n\n\n  Observable.prototype.merge = function (other) {\n    return merge([this, other]);\n  }; // (Array<Stream|Property>) -> Stream\n\n\n  Observable.prototype.concat = function (other) {\n    return concat$1([this, other]);\n  }; // () -> Pool\n\n\n  var pool = function pool() {\n    return new Pool();\n  }; // (Function) -> Stream\n  // Options = {concurLim: number|undefined, queueLim: number|undefined, drop: 'old'|'new'|undefiend}\n  // (Stream|Property, Function|falsey, Options|undefined) -> Stream\n\n\n  Observable.prototype.flatMap = function (fn) {\n    return new FlatMap(this, fn).setName(this, 'flatMap');\n  };\n\n  Observable.prototype.flatMapLatest = function (fn) {\n    return new FlatMap(this, fn, {\n      concurLim: 1,\n      drop: 'old'\n    }).setName(this, 'flatMapLatest');\n  };\n\n  Observable.prototype.flatMapFirst = function (fn) {\n    return new FlatMap(this, fn, {\n      concurLim: 1\n    }).setName(this, 'flatMapFirst');\n  };\n\n  Observable.prototype.flatMapConcat = function (fn) {\n    return new FlatMap(this, fn, {\n      queueLim: -1,\n      concurLim: 1\n    }).setName(this, 'flatMapConcat');\n  };\n\n  Observable.prototype.flatMapConcurLimit = function (fn, limit) {\n    return new FlatMap(this, fn, {\n      queueLim: -1,\n      concurLim: limit\n    }).setName(this, 'flatMapConcurLimit');\n  }; // (Stream|Property, Function|falsey) -> Stream\n\n\n  Observable.prototype.flatMapErrors = function (fn) {\n    return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n  }; // Combine two observables\n  // -----------------------------------------------------------------------------\n  // (Stream, Stream|Property) -> Stream\n  // (Property, Stream|Property) -> Property\n\n\n  Observable.prototype.filterBy = function (other) {\n    return filterBy(this, other);\n  }; // (Stream, Stream|Property, Function|undefiend) -> Stream\n  // (Property, Stream|Property, Function|undefiend) -> Property\n\n\n  Observable.prototype.sampledBy = function (other, combinator) {\n    return sampledBy(this, other, combinator);\n  }; // (Stream, Stream|Property) -> Stream\n  // (Property, Stream|Property) -> Property\n\n\n  Observable.prototype.skipUntilBy = function (other) {\n    return skipUntilBy(this, other);\n  }; // (Stream, Stream|Property) -> Stream\n  // (Property, Stream|Property) -> Property\n\n\n  Observable.prototype.takeUntilBy = function (other) {\n    return takeUntilBy(this, other);\n  }; // Options = {flushOnEnd: boolean|undefined}\n  // (Stream, Stream|Property, Options|undefined) -> Stream\n  // (Property, Stream|Property, Options|undefined) -> Property\n\n\n  Observable.prototype.bufferBy = function (other, options) {\n    return bufferBy(this, other, options);\n  }; // Options = {flushOnEnd: boolean|undefined}\n  // (Stream, Stream|Property, Options|undefined) -> Stream\n  // (Property, Stream|Property, Options|undefined) -> Property\n\n\n  Observable.prototype.bufferWhileBy = function (other, options) {\n    return bufferWhileBy(this, other, options);\n  }; // Deprecated\n  // -----------------------------------------------------------------------------\n\n\n  var DEPRECATION_WARNINGS = true;\n\n  function dissableDeprecationWarnings() {\n    DEPRECATION_WARNINGS = false;\n  }\n\n  function warn(msg) {\n    if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {\n      var msg2 = '\\nHere is an Error object for you containing the call stack:';\n      console.warn(msg, msg2, new Error());\n    }\n  } // (Stream|Property, Stream|Property) -> Property\n\n\n  Observable.prototype.awaiting = function (other) {\n    warn('You are using deprecated .awaiting() method, see https://github.com/kefirjs/kefir/issues/145');\n    return awaiting(this, other);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.valuesToErrors = function (fn) {\n    warn('You are using deprecated .valuesToErrors() method, see https://github.com/kefirjs/kefir/issues/149');\n    return valuesToErrors(this, fn);\n  }; // (Stream, Function|undefined) -> Stream\n  // (Property, Function|undefined) -> Property\n\n\n  Observable.prototype.errorsToValues = function (fn) {\n    warn('You are using deprecated .errorsToValues() method, see https://github.com/kefirjs/kefir/issues/149');\n    return errorsToValues(this, fn);\n  }; // (Stream) -> Stream\n  // (Property) -> Property\n\n\n  Observable.prototype.endOnError = function () {\n    warn('You are using deprecated .endOnError() method, see https://github.com/kefirjs/kefir/issues/150');\n    return endOnError(this);\n  }; // Exports\n  // --------------------------------------------------------------------------\n\n\n  var Kefir = {\n    Observable: Observable,\n    Stream: Stream,\n    Property: Property,\n    never: never,\n    later: later,\n    interval: interval,\n    sequentially: sequentially,\n    fromPoll: fromPoll,\n    withInterval: withInterval,\n    fromCallback: fromCallback,\n    fromNodeCallback: fromNodeCallback,\n    fromEvents: fromEvents,\n    stream: stream,\n    constant: constant,\n    constantError: constantError,\n    fromPromise: fromPromise,\n    fromESObservable: fromESObservable,\n    combine: combine,\n    zip: zip,\n    merge: merge,\n    concat: concat$1,\n    Pool: Pool,\n    pool: pool,\n    repeat: repeat,\n    staticLand: staticLand\n  };\n  Kefir.Kefir = Kefir;\n  exports.dissableDeprecationWarnings = dissableDeprecationWarnings;\n  exports.Kefir = Kefir;\n  exports.Observable = Observable;\n  exports.Stream = Stream;\n  exports.Property = Property;\n  exports.never = never;\n  exports.later = later;\n  exports.interval = interval;\n  exports.sequentially = sequentially;\n  exports.fromPoll = fromPoll;\n  exports.withInterval = withInterval;\n  exports.fromCallback = fromCallback;\n  exports.fromNodeCallback = fromNodeCallback;\n  exports.fromEvents = fromEvents;\n  exports.stream = stream;\n  exports.constant = constant;\n  exports.constantError = constantError;\n  exports.fromPromise = fromPromise;\n  exports.fromESObservable = fromESObservable;\n  exports.combine = combine;\n  exports.zip = zip;\n  exports.merge = merge;\n  exports.concat = concat$1;\n  exports.Pool = Pool;\n  exports.pool = pool;\n  exports.repeat = repeat;\n  exports.staticLand = staticLand;\n  exports['default'] = Kefir;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}