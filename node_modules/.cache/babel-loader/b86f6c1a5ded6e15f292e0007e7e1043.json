{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Kirill Serchenko\\\\Desktop\\\\game_time\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Tags = exports.TagsRaw = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _InputGroup = require(\"../inputGroup/InputGroup\");\n\nvar _Text = require(\"../text/Text\");\n\nvar _BaseInput2 = require(\"../base/input/BaseInput\");\n\nvar _Button = require(\"../button/Button\");\n\nvar _TagsSuggestions = _interopRequireDefault(require(\"./subComponents/TagsSuggestions\"));\n\nvar _withFormContext = require(\"../form/withFormContext\");\n\nvar ReactDOM = _interopRequireWildcard(require(\"react-dom\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar PlusIcon = function PlusIcon(props) {\n  return React.createElement(\"svg\", props, React.createElement(\"path\", {\n    d: \"M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z\"\n  }));\n};\n\nPlusIcon.defaultProps = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: \"24\",\n  height: \"24\",\n  viewBox: \"0 0 24 24\"\n};\n\nvar TagsRaw =\n/*#__PURE__*/\nfunction (_BaseInput) {\n  _inherits(TagsRaw, _BaseInput);\n\n  function TagsRaw(props) {\n    var _this;\n\n    _classCallCheck(this, TagsRaw);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TagsRaw).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"textRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onTextErrorsChanged\", function (textErrors) {\n      return _this.setState(function () {\n        return {\n          textErrors: textErrors\n        };\n      }, function () {\n        return _this.handleErrors();\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onFocus\", function () {\n      _this.setState({\n        textIsFocused: true,\n        suggestionsVisible: true,\n        touched: true\n      }, function () {\n        return _this.handleErrors();\n      });\n\n      _this.fetchExistingTags();\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onKeyDown\", function (suggestions) {\n      return (\n        /*#__PURE__*/\n        function () {\n          var _ref = _asyncToGenerator(\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee(e) {\n            var existingTag, _preselectedSuggestion, _preselectedSuggestion2;\n\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!(e.key === 'Enter' && (_this.state.value !== '' || _this.state.preselectedSuggestion !== undefined) && _this.state.textErrors.length === 0)) {\n                      _context.next = 18;\n                      break;\n                    }\n\n                    e.preventDefault();\n                    e.stopPropagation();\n                    existingTag = _this.props.existingTags && _this.props.existingTags.find(function (et) {\n                      return et.name === _this.state.value;\n                    });\n\n                    if (!(_this.state.preselectedSuggestion !== undefined)) {\n                      _context.next = 9;\n                      break;\n                    }\n\n                    _this.props.onTagsChanged(_this.props.tags.concat(suggestions[_this.state.preselectedSuggestion]));\n\n                    _this.setState({\n                      value: '',\n                      preselectedSuggestion: undefined\n                    }, function () {\n                      _this.fetchExistingTags();\n\n                      _this.handleErrors();\n                    });\n\n                    _context.next = 18;\n                    break;\n\n                  case 9:\n                    if (!existingTag) {\n                      _context.next = 14;\n                      break;\n                    }\n\n                    _this.props.onTagsChanged(_this.props.tags.concat(existingTag));\n\n                    _this.setState({\n                      value: ''\n                    }, function () {\n                      _this.fetchExistingTags();\n\n                      _this.handleErrors();\n                    });\n\n                    _context.next = 18;\n                    break;\n\n                  case 14:\n                    if (!_this.props.allowNew) {\n                      _context.next = 18;\n                      break;\n                    }\n\n                    _context.next = 17;\n                    return _this.addNewTag();\n\n                  case 17:\n                    _this.handleErrors();\n\n                  case 18:\n                    if (suggestions.length > 0 && _this.state.suggestionsVisible) {\n                      if (e.key === 'ArrowUp') {\n                        _preselectedSuggestion = _this.state.preselectedSuggestion === undefined ? suggestions.length - 1 : _this.state.preselectedSuggestion === 0 ? suggestions.length - 1 : _this.state.preselectedSuggestion - 1;\n\n                        _this.setState({\n                          preselectedSuggestion: _preselectedSuggestion\n                        });\n                      } else if (e.key === 'ArrowDown') {\n                        _preselectedSuggestion2 = _this.state.preselectedSuggestion === undefined ? 0 : _this.state.preselectedSuggestion === suggestions.length - 1 ? 0 : _this.state.preselectedSuggestion + 1;\n\n                        _this.setState({\n                          preselectedSuggestion: _preselectedSuggestion2\n                        });\n                      } else {\n                        _this.setState({\n                          preselectedSuggestion: undefined\n                        });\n                      }\n                    }\n\n                  case 19:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this);\n          }));\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()\n      );\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"addNewTag\",\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      var newTag;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _this.props.onNewTagAdded(_this.state.value);\n\n            case 2:\n              newTag = _context2.sent;\n\n              if (newTag) {\n                _this.props.onTagsChanged(_this.props.tags ? _this.props.tags.concat(newTag) : [newTag]);\n              }\n\n              _this.setState({\n                value: '',\n                textErrors: []\n              }, function () {\n                _this.fetchExistingTags();\n\n                _this.handleErrors();\n              });\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    })));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onSuggestionSelected\", function (tag) {\n      _this.props.onTagsChanged(_this.props.tags.concat(tag));\n\n      _this.setState({\n        value: '',\n        preselectedSuggestion: undefined,\n        textErrors: []\n      }, function () {\n        _this.fetchExistingTags();\n\n        _this.handleErrors();\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onBlur\", function () {\n      _this.setState({\n        textIsFocused: false,\n        preselectedSuggestion: undefined\n      }, function () {\n        return _this.handleErrors();\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onClickOutside\", function () {\n      return _this.setState({\n        suggestionsVisible: false,\n        preselectedSuggestion: undefined\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onTextChanged\", function (e, isValid) {\n      var value = e.target.value;\n\n      _this.setState(function () {\n        return {\n          value: value,\n          isValid: isValid,\n          textIsValid: isValid,\n          suggestionsVisible: true\n        };\n      }, function () {\n        return _this.handleErrors();\n      });\n\n      _this.fetchExistingTags(e.target.value);\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleErrors\", function () {\n      var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.tags;\n\n      var errors = _this.getErrors(tags);\n\n      if (errors.length > 0) {\n        _this.setInvalid(errors);\n      } else {\n        _this.setValid();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"tagRemoveClick\", function (tag) {\n      return function () {\n        var newTags = _this.props.tags.filter(function (sv) {\n          return sv.id !== tag.id;\n        });\n\n        _this.props.onTagsChanged && _this.props.onTagsChanged(newTags);\n\n        _this.handleErrors(newTags);\n\n        _this.fetchExistingTags();\n      };\n    });\n\n    _this.state = _objectSpread({}, _this.state, {\n      textErrors: [],\n      textIsFocused: false,\n      suggestionsVisible: false,\n      fetchingExistingTags: false,\n      textIsValid: false\n    });\n    _this.textRef = React.createRef();\n    return _this;\n  }\n\n  _createClass(TagsRaw, [{\n    key: \"focus\",\n    value: function focus() {\n      if (this.textRef.current && this.textRef.current.inputRef) {\n        var domNode = ReactDOM.findDOMNode(this.textRef.current.inputRef.current);\n        domNode && domNode.focus();\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps.tags !== this.props.tags || nextProps.validators !== this.props.validators || nextProps.customValidators !== this.props.customValidators || nextProps.required !== this.props.required) {\n        this.handleErrors(nextProps.tags);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var textProps = this.props.textProps ? this.props.textProps : {};\n      var suggestions = this.getSuggestions();\n      return React.createElement(_InputGroup.InputGroup, {\n        title: this.props.title\n      }, React.createElement(\"div\", {\n        className: 'input__base tags-input ' + this.getValidationClass() + (this.props.className ? ' ' + this.props.className : '') + ' ' + (this.props.readOnly ? 'tags-input--readOnly ' : ''),\n        ref: this.containerRef\n      }, this.renderTags(), (!this.props.maxTags || this.props.maxTags > (this.props.tags && this.props.tags.length)) && !this.props.readOnly && React.createElement(\"div\", {\n        className: 'tags-input__tags__wrapper ' + (this.props.readOnly ? 'filled ' : '')\n      }, React.createElement(_Text.Text, _extends({}, textProps, {\n        innerRef: this.textRef,\n        required: this.props.tags.length > 0 ? false : this.props.required,\n        className: 'tags-input__text-input ' + (textProps.className ? textProps.className : ''),\n        onKeyDown: this.onKeyDown(suggestions),\n        onErrorsChanged: this.onTextErrorsChanged,\n        onChange: this.onTextChanged,\n        onFocus: this.onFocus,\n        onBlur: this.onBlur,\n        value: this.state.value,\n        readOnly: this.props.readOnly,\n        showValidation: false,\n        ignoreContext: true,\n        validators: this.props.validators,\n        customValidators: this.props.customValidators\n      })), this.state.suggestionsVisible && this.props.showSuggestions && React.createElement(_TagsSuggestions.default, {\n        allowNew: this.props.allowNew,\n        preselectedSuggestion: this.state.preselectedSuggestion,\n        loading: this.state.fetchingExistingTags,\n        LoadingComponent: this.props.suggestionsLoadingComponent,\n        isVisible: this.state.suggestionsVisible,\n        EmptyComponent: this.props.suggestionsEmptyComponent,\n        tags: suggestions,\n        onSelected: this.onSuggestionSelected,\n        onClickOutside: this.onClickOutside,\n        value: this.state.value,\n        AddNewTagComponent: this.props.allowNew && this.state.value !== '' && this.state.textIsValid && React.createElement(_Button.Button, {\n          dropdown: true,\n          onClick: this.addNewTag\n        }, \"Add new \\\"\", this.state.value, \"\\\"\")\n      })), this.renderDefaultValidation(), this.props.label && React.createElement(\"label\", {\n        className: this.state.value !== '' || this.state.textIsFocused || this.props.readOnly || this.props.tags.length >= this.props.maxTags ? 'label--focused' : ''\n      }, this.renderLabel())));\n    }\n  }, {\n    key: \"getErrors\",\n    value: function getErrors(tags) {\n      var errors = [];\n\n      if (tags.length < this.props.maxTags) {\n        errors = errors.concat(this.state.textErrors);\n      }\n\n      if (this.state.value !== '' && tags.length === 0 && this.props.required) {\n        errors = errors.concat('Required');\n      }\n\n      if (this.state.value && this.props.allowNew && !this.state.textIsFocused) {\n        errors = errors.concat(this.props.valueNotAddedError);\n      }\n\n      if (this.props.maxTags < (this.props.tags && this.props.tags.length)) {\n        errors = errors.concat(this.props.maxTagsSurpassedError);\n      }\n\n      return errors.filter(function (i) {\n        return i;\n      });\n    }\n  }, {\n    key: \"fetchExistingTags\",\n    value: function fetchExistingTags() {\n      var _this2 = this;\n\n      var startsWith = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (this.props.fetchExistingTags) {\n        var timer = setTimeout(function () {\n          return _this2.setState({\n            fetchingExistingTags: true\n          });\n        }, this.props.loadingDelayMs);\n        this.props.fetchExistingTags(startsWith).then(function (fetchedExistingTags) {\n          clearTimeout(timer);\n\n          _this2.setState({\n            fetchedExistingTags: fetchedExistingTags,\n            fetchingExistingTags: false\n          });\n        });\n      }\n    }\n  }, {\n    key: \"getSuggestions\",\n    value: function getSuggestions() {\n      var _this3 = this;\n\n      var existingTags = [].concat(this.props.existingTags ? this.props.existingTags : []).concat(this.state.fetchedExistingTags ? this.state.fetchedExistingTags : []);\n      var filteredTags = this.props.filterExistingTags(this.state.value ? this.state.value.toLowerCase() : '', existingTags);\n      var suggestions = filteredTags.filter(function (tag) {\n        return !_this3.props.tags.some(function (t) {\n          return t.id === tag.id;\n        });\n      }).slice(0, this.props.maxSuggestions);\n      return suggestions;\n    }\n  }, {\n    key: \"renderTag\",\n    value: function renderTag(tag, index) {\n      return React.createElement(\"div\", {\n        className: \"tags-input__tag\",\n        key: index\n      }, tag.name, !this.props.readOnly && React.createElement(_Button.Button, {\n        circular: true,\n        blank: true,\n        onClick: this.tagRemoveClick(tag),\n        className: \"ml-1 transform-rotate--45 line-height--0 p-0\"\n      }, React.createElement(PlusIcon, null)));\n    }\n  }, {\n    key: \"renderTags\",\n    value: function renderTags() {\n      var _this4 = this;\n\n      return this.props.tags && this.props.tags.length > 0 ? React.createElement(\"div\", {\n        className: \"tags-input__tag__wrapper\"\n      }, this.props.tags.map(function (item, index) {\n        return _this4.renderTag(item, index);\n      })) : this.props.readOnly && React.createElement(\"div\", {\n        className: \"tags-input__tag__wrapper\"\n      }, React.createElement(\"div\", {\n        className: \"tags-input__tag\"\n      }, this.props.readonlyEmptyPlaceholder));\n    }\n  }]);\n\n  return TagsRaw;\n}(_BaseInput2.BaseInput);\n\nexports.TagsRaw = TagsRaw;\n\n_defineProperty(TagsRaw, \"defaultProps\", _objectSpread({}, _BaseInput2.BaseInput.defaultProps, {\n  disabled: false,\n  className: '',\n  tags: [],\n  existingTags: [],\n  maxTags: 1000,\n  onTagsChanged: function onTagsChanged() {\n    return undefined;\n  },\n  onNewTagAdded: function onNewTagAdded(newTagName) {\n    return Promise.resolve({\n      name: newTagName,\n      id: new Date().getTime()\n    });\n  },\n  valueNotAddedError: React.createElement(\"span\", null, \"You forgot to add tag\"),\n  maxTagsSurpassedError: React.createElement(\"span\", null, \"Maximum number of tags surpassed\"),\n  showSuggestions: true,\n  suggestionsLoadingComponent: 'Loading...',\n  suggestionsEmptyComponent: 'No existing tags...',\n  loadingDelayMs: 500,\n  filterExistingTags: function filterExistingTags(text, tags) {\n    return tags.filter(function (tag) {\n      return tag.name && tag.name.toLowerCase().startsWith(text);\n    });\n  },\n  maxSuggestions: 5\n}));\n\nvar Tags = (0, _withFormContext.withFormContext)(TagsRaw);\nexports.Tags = Tags;\nvar _default = Tags;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}